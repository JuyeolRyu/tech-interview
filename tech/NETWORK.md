# 1. OSI 7계층이란? 

국제 표준화 기구에서 개발한 모델로서 네트워크 프로토콜 디자인과 통신을 계층으로 나누어서 설명한것입니다.  
네트워크 통신이 일어나는과정을 7단계로 나누어 놓은것입니다.  

OSI 7계층은 물리,데이터링크,네트워크,전송,세션,표현,응용 계층으로 나누어 집니다.
 
#### **📝OSI 7계층을 나누는 이유는?**

> 계층을 나눈 이유는 통신이 일어나는 과정을 단계별로 파악할수 있기 때문입니다.  
 이를 통해 복잡한 통신의 흐름을 사람이 알아보기 쉽고 문제가 발생했을 경우 문제가 발생한 계층만 보수하여 문제를 해결할 수 있습니다.  
 이는 유지보수 측면에서 큰 강점이기 때문에 계층을 나누어 사용합니다.  
 

#### **📝OSI 7계층의 각 계층에 대한 설명**

* **물리 계층(1계층)**  

>데이터를 전기적 신호로 변환해서 주고받는 기능을 수행합니다.  
전송하는(받는) **데이터가 무엇인지**, **에러가 존재하는지 알수 없고** 주고 받는 기능만 수행합니다.  
전송단위는 비트이며 케이블, 리피터, 허브등의 장비를 사용합니다.  

* **데이터 링크(2계층)** 

>물리 계층으로 송수신 되는 **정보의 오류와 재전송, 그리고 흐름을 관리**하는 역할을 수행합니다. 
MAC 주소를 사용하여 통신하는데 MAC 주소는 랜카드마다 할당되어있습니다.  
전송단위는 프레임이며 브리지, 스위치등의 장비를 사용합니다. 

* **네트워크(3계층)** 

>논리적인 **주소(IP)체계**와 **라우팅 기능**을 지원합니다.   
그 외에도 **흐름제어, 오류 제어**의 기능을 수행합니다.  
전송단위는 패킷이며 라우터를 사용합니다.  
👉 라우팅 기능이란 데이터를 목적지까지 안전하고 빠르게 전달하는 경로를 찾아서 전송하는 기능입니다.  

* **전송(4계층)** 

>통신을 활성화하기 위한 계층입니다. 포트를 열어서 응용프로그램들이 전송을 가능하도록 합니다. 
단대단 오류, 흐름제어를 담당합니다.  
TCP,UDP 프로토콜을 사용합니다. 

* **세션(5계층)** 

>통신을 위한 논리적 연결을 담당합니다.  
어플리케이션 간 세션을 구축하고 관리하는 역할을 합니다.  
이는 전송모드(전이중, 반이중 ...)을 결정하고 데이터 송수신의 동기를 관리합니다.  

* **표현(6계층)** 

>각각의 어플리케이션이 정보를 잘 통신할수 있도록 필터링하고 변환하는 계층입니다.  
데이터의 확장자 결정과 같은 암호화와 데이터 압축을 수행합니다.  
JPG,MPEG등의 프로토콜이 있습니다. 

* **응용(7계층)** 

>소프트웨어,UI를 담당하는 계층입니다. 
즉 응용 프로세스와 직접 연계하여 서비스를 제공합니다. 
DNS,FTP,HTTP등의 프로토콜이 존재합니다. 
<br/>  
<br/>  
<br/>  

# 2. TCP란? 
OSI 7계층중 4계층(전송)의 프로토콜로서 `신뢰성`을 보장하는 `연결지향 통신` 프로토콜입니다. 
또한 `3 way handshake`의 과정을 거쳐서 연결되고 `4 way handshake`과정을 거처서 연결을 종료합니다.  

#### **📝프로토콜이란?**  
> 프로토콜이란 국가 간의 약속을 의미하고 통신에서는 통신규약을 의미합니다.  
#### **📝TCP가 연결되고 해제하는 과정을 설명하시오.**

>**3way handshake**는 TCP 통신에서 정확한 전송을 보장하기 위한 네트워크 연결 방법입니다. 
클라이언트가 SYN패킷(x) 전송==>서버가 SYN(y)+ACK(x+1)패킷을 전송==>클라이언트가 ACK(y+1)을 전송  

>**4way handshake**는 통신이 끝났을때 네트워크 연결 해제 방법입니다.  
클라이언트가 FIN 패킷 전송==>서버가ACK전송==>서버가 ACK를 모두 전송하면 FIN 패킷을 전송한다 ==>  
클라이언트는 FIN 패킷을 받고 ACK패킷을 전송한다 ==>서버는 ACK패킷을 받고 소켓을 닫는다 ==> 클라이언트도 `TIME WAIT` 동안 기다리다가 소켓을 닫는다.  
👉 클라이언트가 바로 연결을 종료하지 않고 `TIME WAIT`동안 기다리는 이유는 서버가 FIN패킷 전송전에 전송한 패킷이 늦게 도착하는 경우 데이터 유실을 방지하기 위함 때문입니다.  
<br/>  
<br/>  
<br/>  

# 3. UDP란?  
OSI 7계층중 4계층(전송)의 프로토콜로서 TCP와는 다르게 신뢰성을 보장하지 않고 비연결지향 통신 프로토콜입니다.  
패킷이 제대로 전송되었는지 확인하는 과정이 없기 때문에(비신뢰성) 때문에 TCP에 비해 속도가 빠르다는 장점이 있습니다.  
<br/>  
<br/>  
<br/>  


# 4. 흐름제어란 무엇인가? 
송신과 수신측의 데이터 처리 속도 차이를 해결하기 위한 기법입니다.  
송신측의 전송속도가 수신측의 처리속도보다 빠를경우 문제가 생깁니다. 따라서 송신측의 데이터 전송량을 수신측에 따라 조절해 줍니다.  
이러한 흐름제어의 방식에는 **Stop-wait** 방식과 **Sliding window** 방식이 있습니다.  

#### **📝Stop-wait 방식이란?**  
>송수신간 처리속도 차이로 인해 발생하는 문제를 해결하는 기법인 흐름제어 중 하나입니다.  
전송한 패킷에 대해 확인 응답을 받고 다음 패킷을 전송하는 방식입니다.  
하나를 전송하기 기다려야하기 때문에 비효율적이고 속도가 느리다는 단점이 있습니다.  
  
#### **📝Sliding window 방식이란?**  
>송수신간 처리속도 차이로 인해 발생하는 문제를 해결하는 기법인 흐름제어 중 하나입니다.   
기존의 방식인 Stop-wait방식을 개선한 방법으로 수신 측에서 설정한 윈도우 크기만큼 전송하는 방식입니다.  
전송한 패킷에 대한 응답 패킷을 받으면 해당 패킷만큼 윈도우를 옮겨서 전송하는 방식입니다.  
<br/>  
<br/>  
<br/>  


# 5. 혼잡제어란 무엇인가?  
송신측과 네트워크의 데이터 처리속도 차이로 인해 발생하는 문제를 해결하기 위한 기법입니다.  
하나의 라우터에 다수의 데이터가 몰리게 된 경우 모든 데이터를 처리할수 없게 되는 경우 송신측의 데이터 전송속도를 제어해서 해결하는 방법입니다.  
혼잡제어의 종류에는 **AIMD**, **Slow start**, **빠른 재전송**, **빠른 회복**이 있습니다.  

#### **📝AIMD(Additive Increase Multicative Decrease)**  
>초기 송신시 패킷을 하나씩 보내다가 문제가 없으면 윈도우의 크기를 증가시켜가며 전송하는 방식입니다.  
만약 패킷 전송을 실패하거나 응답 시간이 오래 걸리면 패킷 전송 속도를 반으로 줄여가면서 조절하는 방식입니다.  
공평하게 네트워크를 사용한다는 장점이 있지만 전송속도를 확보하는데 시간이 오래걸리고 혼잡을 미리 예측하지 못한다는 단점이 있습니다.  

#### **📝Slow start**  
>AIMD처럼 선형으로 윈도우의 크기를 증가시키는 것이 아니라 지수형태로 증가시키는 방법입니다.   
하지만 전송속도가 임계점을 넘어가면 선형으로 증가시키는 방법을 사용합니다. 그러다 혼잡이 발생하면 윈도우의 크기를 1로 떨어뜨려서 혼잡 제어를 합니다.  

#### **📝Fast retransmit(빠른 재전송)**  
>패킷이 제대로 전송되면 마지막으로 제대로 수신한 ACK패킷을 응답합니다.  
이때 패킷이 중간에 손실된 경우 특정 ACK패킷이 중복으로 수신되게 되므로 혼잡을 감지하고 윈도우의 크기를 줄이는 방식입니다.   
  
#### **📝Fast recovery(빠른 회복)**   
>혼잡 상태가 되었을때 윈도우의 크기를 1로 줄이는 것이 아니라 절반으로 줄이고 선형으로 증가시키는 방법입니다.  

<br/>  
<br/>  
<br/>  

# 6. HTTP 와 HTTPS란?  
`HTTP`는 클라이언트와 서버가 데이터를 주고 받을 때 사용하는 **응용계층**의 프로토콜입니다.  
데이터를 주고 받는 형태는 메시지 형태이고 **무상태**, **비연결성**의 특징을 가집니다.  
이러한 특성 때문에 불특정 다수에게 서비스를 제공하는데 유리합니다.  
  
`HTTPS`는 HTTP의 메세지가 노출될수 있다는 보안의 약점을 보완하기 위해 **HTTP** 와 **SSL** 프로토콜을 같이 사용하는 것을 의미합니다.  
쉽게 말하면 HTTP의 메세지를 SSL을 사용하여 공개키 암호화 방식을 사용해 **암호화**해서 전송하는 것을 의미합니다.  

#### **📝비연결성과 무상태성란?**  
>클라이언트에서 요청하고 서버가 응답하면 바로 연결을 해제하는 것을 의미합니다.  
바로 연결을 해제하기 때문에 클라이언트의 이전 상태를 기억하지 못하므로 무상태성의 특징을 가집니다.  

#### **📝HTTP의 단점을 보완할 방법은 무엇이 있는지?**  
>HTTP의 단점인 무상태성을 보완하기 위해 **쿠키**, **세션**, **토큰**을 사용합니다.  
최근에는 무상태 특징을 보완하기 위해 쿠키,세션을 사용하여 이전상태를 반영구적으로 기억할수 있기도 합니다.  

#### **📝SSL Handshake**  
> HTTPS는 TCP기반의 프로토콜이기 때문에 우선 TCP 3way Handshake를 실시합니다.  
> 그 뒤에 SSL클라이언트가 서버에 연결을 시도하는 패킷(client hello)을 전송합니다. 그리고 SSL서버는 **암호화 방식**과 클라이언트 요청시 **SSL인증서**를 클라이언트에게 전송합니다.  
> 이때 인증서 내부에는 서버에서 발행한 **공개키**가 있는데 이를 사용해 **인증서를 복호**화합니다. 만약 복호화가 된다면 **적합한 서버임을 확인**할수 있습니다.  
> 그리고 클라이언트는 **대칭키를 생성**하고 SSL인증서 내부에 있던 공개키를 사용해 암호화해서 서버에 전송합니다.  
> 서버에서는 기존에 가지고 있던 **비밀키**를 사용해 클라이언트가 전송한 **대칭키**를 얻을수 있습니다.  
> 이제 클라이언트와 서버 모두 키를 가졌으므로 **Finished**패킷을 전송해 **SSL Handshake**를 종료합니다.  
<br/>  
<br/>  
<br/>  

# 7. 쿠키,세션,토큰
#### **📝쿠키**  
> 쿠키란 **HTTP 비상태성의 한계를 극복**하기 위해 사용하는 기법입니다.  
> 쿠키는 서버가 클라이언트의 브라우저에 저장하고 key,value형태로 저장됩니다.  
> 브라우저가 종료되도 쿠키는 남아있고 아이디,비밀번호,팝업창을 저장해서 **UX를 향상**시켜줍니다.  
> 클라이언트에 저장되기 때문에 **빠르다**는 장점과 **보안에 취약**하다는 단점이 있습니다.  

#### **📝세션** 
> 쿠키를 매개로 하지만, 사용자의 정보 파일인 **세션ID**를 관리하는 방법입니다.  
> 로그인을 유지하고 **클라이언트를 구분**하기 위해 사용합니다.  
> 브라우저를 종료하면 세션이 만료된다는 특징이 있고 서버에 저장되기 때문에 **서버에 부하**가 생길수 있습니다.  
> 서버에 저장되기 때문에 **보안성이 좋지만** 쿠키보다는 처리가 **느리다**는 단점이 있습니다.

#### **📝토큰** 
> 토큰은 **인증에 필요한 정보를 암호화**시킨 것을 의미합니다.  
> 만약 유저가 로그인을 하면 서버는 이를 확인하고 인증에 필요한 토큰을 발급합니다. 이제 클라이언트는 해당 토큰을 가지고 인증을 하면 됩니다.  
> 쿠키/세션과 달리 토큰만 가지고 인증하기 때문에 **별도의 저장소가 필요하지 않습니다**. 또한 유효기간이 만료되기 전까지 사용가능하고 후에 재발급해서 사용하면 된다.  
> 하지만 유효기간 때문에 토큰이 악의적으로 사용되도 유효기간전까지 삭제할수 없다는 단점이 있습니다. 이러한 문제는 **Access Token**의 수명은 짧게 하고, **Refresh Token**을 새로 발급하면 됩니다.

<br/>  
<br/>  
<br/>  

# 8. IP주소
`IP주소`는 네트워크에서 장치들이 서로를 인식하고 통신하기 위한 논리적 주소입니다.  
또한 IP주소는 **IPV4**와 **IPV6**로 나누어지고 계층적 구조라는 특징을 가지고 있습니다.  
IP 주소를 구분하는 방법은 Class를 통해 구분합니다. 실제 네트워크에서 사용되는 클래스는 A,B,C입니다.  
**A Class**의 경우 왼쪽 8비트가 네트워크 id이고 나머지 비트는 호스트 id입니다. **B Class**는 앞의 16비트가 네트워크 id, **C Class**는 앞의 24비트가 네트워크 id입니다.  
그리고 **D Class**는 멀티캐스트, **E Class**는 예비용으로 남겨져 있습니다.  
따라서 A가 가장 많은 host를 보유하고 할수 있습니다.

#### **📝IPV4**  
> 일반적인 IP주소 체계입니다.  총 32비트로 이루어져있고 43억개정도의 주소를 표현할수 있습니다.  
> 하지만 현재는 부족해서 IPV6를 사용하고 있습니다.  
#### **📝IPV6**  
> IPV4주소의 개수가 부족해서 새롭게 만든 주소 체계입니다.  
> 총 주소의 길이는 128비트이고 16진수로 표현됩니다.  
#### **📝IP주소 할당 방식**  
> IP주소 할당 방식은 **고정IP** 방식과 **유동IP** 방식 2가지가 있습니다.  
> **고정IP**의 경우 한번 할당 받은 주소를 반납하기 전까지는 계속 해당 주소를 사용하는 방식입니다.  
> **유동IP**는 고정IP와 다르게 인터넷에 접속할때만 IP를 할당받고 접속이 끝나면 IP를 반환하는 방식입니다. 또한 주기적으로 주소가 변경되기 때문에 보안측면에서 더 좋습니다.  
> 그리고 유동IP는 **DHCP서버**에서 가지고 있는 IP주소를 할당받아 사용하고 반납합니다.  
<br/>  
<br/>  
<br/>  


# 9. 주소검색과정
우선 **목적지의 IP주소**를 확인해야 합니다.  
**브라우저 캐시**나 **로컬 host**에 해당되는 IP주소가 있다면 사용하고 없다면 **DNS서버**에 요청을 보내 목적지 IP주소를 응답받습니다.  
그리고 **자신의 IP주소**와 **가장 가까운 라우터의 IP주소**를 알아내기 위해 **DHCP서버**에 요청해 응답받습니다.  
다음으로 라우터 IP주소를 **ARP프로토콜**을 사용해 MAC주소를 알아냅니다.  
위의 과정을 통해 다음 라우터로 데이터를 전송하면 다음 라우터에서 목적지까지 도착할때까지 **최적의 라우터를 탐색하는 과정을 반복**합니다.  
목적지에 도착하면 전송 계층에서 port정보를 꺼내 어떤 프로세스에 접근해야 하는지 판단합니다.  
그리고 응용계층을 지나 HTTP프로토콜에 따라 필요한 데이터를 탐색합니다. 검색된 데이터를 다시 위의 **역순으로 전송**해주면 웹페이지를 받게 됩니다.  

#### **📝MAC주소 알아내는 방법**  
> 브로드캐스트로 IP주소를 포함한 패킷을 전송하면 동일한 주소를 가지고 있는 라우터에서 자신의 MAC주소를 응답해줍니다.  
<br/>  
<br/>  
<br/>  

# 10. 로드밸런싱이란?  
서버에 트래픽이 몰릴 경우 이를 분산시켜서 트래픽 문제를 해결하는 방법을 말합니다.  
서버를 여러 개 두고 로드밸런서가 클라이언트의 접속을 분산시켜주는 역할을 합니다.  
라운드 로빈 방식을 사용하여 스케줄링을 진행하고 같은 IP에서의 접근하면 항상 같은 서버로 연결되는것을 보장해줍니다.  

#### **📝스케일업과 스케일 아웃**   
> `스케일업`은 서버 자체의 **스펙을 증가**시켜서 서버 부하 문제를 해결하는 것을 의미합니다.  
> 더 좋은 스펙의 서버로 변경하는 것이므로 확장성이 떨어진다는 단점이 있습니다.  
> **정합성 유지**(데이터가 일관성이 있는것) 조건이 어려운 경우 사용합니다.  

> `스케일 아웃`은 **서버의 개수를 증가**시켜서 서버 부하 문제를 해결하는 것을 의미합니다.  
> 스케일 아웃이 비교적 **확장성**,**서버비용**,**장애에 강인**하지만 운영비용이나 관리가 힘들다는 단점이 존재합니다.  
> **정합성 유지**(데이터가 일관성이 있는것) 조건이 어렵지 않은 경우 사용합니다.  

#### **📝서버에 트래픽이 몰릴경우 대처방법**  
> **스케일업**과 **스케일 아웃**이 있다.  
> 그 외에도 **웹 캐시**를 사용하여 웹서버에서 컨텐츠를 매번 요청하여 받아오는 것이 아니라 웹캐시 서버에서 불러와서 사이트의 **응답시간**과 **트래픽**을 감소시키는 효과를 얻을수 있습니다.  
> 추가로 **MSA(MicroService Architecture)** 를 사용하는 방법도 존재합니다. MSA는 API를 사용해서 서비스의 end-point에 접근하고 세부사항은 추상화합니다.  
> 따라서 각각의 서비스는 따로 **모듈화**가 되어 있으므로 모듈마다 **기술스택을 다르게 사용**할수도 있고 **서비스별로 scale-out**이 가능하다는 장점이 있습니다.  
> 하지만 **트랜잭션 유지**, **통합테스트의 어려움**, **복잡함**이라는 단점이 존재합니다.  

<br/>  
<br/>  
<br/> 

# 11. Blocking/Non-blocking & Synchronous/Asynchronous  
**블럭**,**논블럭**은 **제어권**을 누가 가지고 있느냐의 차이입니다.  
우선 **블럭**의 경우 호출된 함수에게 제어권을 넘겨주고 **논블럭**의 경우 호출된 함수를 실행하고 바로 제어권을 가져옵니다. 따라서 논블럭은 호출된 함수를 기다리면서 다른 일을 수행할수 있습니다.  
  
**동기**,**비동기**는 **동시성**에 중점을 두고 봐야합니다.  
**동기**는 호출된 함수의 상태를 본래 함수에서 계속해서 확인하는 것이고 **비동기**는 호출된 함수에서 스스로 상태를 보고 call back을 전달하여 완료여부를 본래 함수에게 알립니다.  

<br/>  
<br/>  
<br/> 

# 12. 네트워크 오류  
네트워크에서 데이터를 전송시 **감쇠**,**지연**,**잡음**,**외곡**의 이유로 오류가 발생할수 있습니다.  
그리고 이러한 오류를 제어하는 방식은 스스로 오류를 검출해 수정하는 **FEC**, 수신측에서 재전송을 요구하는 **BEC**방식이 있습니다.  
BEC의 경우 패리티,CRC,체크섬,해밍코드등을 사용해 오류를 검출하게 됩니다.  

#### **📝패리티 검사**  
> **1차원 패리티**는 1의 개수를 짝수 또는 홀수로 보낼지 약속하고 전송하게 됩니다. 그리고 수신측에서 1의 개수를 검사했을때 다르면 오류를 검출하는 방식입니다.  
> 이 경우 1개의 오류만 검출할수 있고 어디서 오류가 발생했는지 알수 없습니다. 또한 변경된 비트의 개수가 짝수이면 오류를 검출하지 못합니다.  

> 이러한 문제를 해결하기 위해 **2차원 패리티**가 등장했습니다.  
> 2차원 패리티는 말 그대로 패리티비트를 2차원으로 보냅니다. 이 경우 1차원 패리티에서 짝수개의 오류를 검출하지 못하던 점을 해결했지만 여전히 행열 모두 짝수개씩 변경됐다면 검출하지 못합니다.  

#### **📝CRC**  
> 전송할 데이터에 (CRC코드 최고차수)비트를 붙이고 CRC코드로 XOR 한 값을 구합니다.  
 그리고 전송할 데이터 뒤에 위에서 구한 값을 붙이고 전송합니다.  
 데이터를 수신하면 CRC코드로 나누고 결과가 0이면 오류가 없는 것이고 다른 값이 나오면 오류가 발생한 것입니다.  
 주로 **데이터 링크 계층**에서 사용됩니다.  

#### **📝체크섬**  
> 송신할 데이터를 전부 더한 다음 앞의 4비트를 버립니다. 그리고 그 값의 2의 보수를 구해 체크섬을 생성합니다.
> 데이터를 수신받으면 모든 데이터와 체크섬을 더합니다. 그리고 앞의 4비트를 버렸을때 0이 나오면 오류가 없고 0이 아닌 값이 나오면 오류가 발생했다고 판단합니다.  

#### **📝해밍코드**  
> 오류를 **검출**하고 **수정**할수 있는 오류검출 방법입니다.  
> 

