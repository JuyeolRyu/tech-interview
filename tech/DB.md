# **\[데이터베이스\]** 
---
# 1.인덱스란 무엇인가  

데이터 값과 데이터의 주소가 같이 저장된 것을 의미합니다.  
데이터의 탐색에는 효율적이지만 데이터 삽입,삭제,수정에는 시간이 더 많이 걸리게 됩니다.  
인덱스 알고리즘은 b+tree, hash 인덱스 알고리즘이 있습니다.  
hash인덱스는 시간복잡도가O(1)이지만 데이터의 일부분으로 검색할수 없어서 범위탐색시에는 오히려 b+tree보다 오래걸린다는 특징이 있습니다.  
  
### 1.1 인덱스를 사용할때 탐색은 속도가 올라가고 삽입,삭제,갱신은 속도가 느려지는 이유가 무엇입니까  

인덱스는 데이터&주소가 맵핑되어있고 정렬되어있습니다. 따라서 원하는 데이터가 어떤 주소에 저장되어있는지 알기 때문에 검색속도는 올라가게 됩니다.  
하지만 삽입,삭제,갱신에는 정렬된 상태를 유지해서 데이터를 관리하고 인덱스 테이블도 관리해야 하기 때문에 속도가 느려질수 있습니다.  

  
### 1.2 인덱스 알고리즘에는 어떤 종류가 있고 특징을 설명하시오 

`B-tree`,`B+tree` 알고리즘과 `Hash` 알고리즘이 있습니다.  

B-tree는 balanced tree로 정렬된 상태로 유지되고 노드 전체에 데이터가 저장되어 있습니다.  

B+tree 인덱스는 말그대로 트리형태로 인덱스를 구분해서 나누어 놓은것입니다.  
B+tree의 경우 삽입,삭제 시 자동으로 구조를 유지하기 때문에 테이블의 구조를 재구성할 필요가 없기 때문에 사용합니다.  
또한 범위 탐색시 유리하다는 장점이 있습니다.  
이러한 장점 때문에 대부분의 관계형 DB에서 B+tree를 지원하고 있습니다.  

해시는 컬럼 값의 해시값을 계산해서 저장하므로 검색속도가 빠릅니다.  
하지만 해시값으로 탐색하므로 값의 일부분만으로 검색할수 없습니다.  

👉**B+tree 삽입**  
![image](https://user-images.githubusercontent.com/49298852/140603501-fff2f0f2-85ed-4a86-84f8-2229e345c404.png)
위의 트리에 Adams를 삽입하라.  

👉**B+tree 삭제**  
![image](https://user-images.githubusercontent.com/49298852/140603501-fff2f0f2-85ed-4a86-84f8-2229e345c404.png)  
위의 트리에서 Srinivasan를 삭제하라.  

❗[정답](https://ju-hy.tistory.com/106)  

### 1.3 primary index(기본인덱스)와 secondary index(보조인덱스) 의 차이점을 설명하시오 

기본 인덱스는 기본키를 포함하는 인덱스로서 키의 순서가 레코드의 순서르 결정짓습니다. 
보조 인덱스는 기본키 이외의 인덱스이고 키의 순서가 레코드의 순서를 의미하지 않습니다. 


### 1.4 클러스터드(Clustered) 인덱스와 넌클러스터드(Non-Clustered) 인덱스의 차이는 무엇입니까  

`클러스터드 인덱스`는 물리적으로 정렬되어 있는 상태로 데이터가 저장되는 것이고 1개만 생성이 가능합니다.  
기본키 설정 시 기본키를 기준으로 클러스터드 인덱스가 생성됩니다.  
인덱스 자체의 리프 페이지가 데이터입니다. 이 말은 테이블 자체가 인덱스라는 의미이고 별도의 인덱스 테이블이 생성되지 않습니다.  
  
`넌클러스터드 인덱스`는 레코드 원본은 정렬되어 있지 않고 인덱스 테이블만 정렬되어있는 인덱스입니다.  
**클러스터드 인덱스**보다 검색 속도는 느리지만 삽입,삭제,변경의 속도는 더 빠릅니다.  
별도의 인덱스 테이블을 생성하므로 용량을 추가로 차지합니다.  

### 1.5 컴포지트(Composite) 인덱스란 무엇입니까  
 
인덱스를 생성할때 두 개 이상의 컬럼을 합쳐서 인덱스를 만드는것을 의미합니다.  
두개 이상의 컬럼을 같이 사용하기 때문에 "and" 연산으로 여러 조건을 같이 탐색할때 유리합니다.  

---
# 2.키에 대해 설명하시오  
키는 데이터베이스에서 조건을 만족하는 튜플을 구분할수 있는 속성의 조합을 의미합니다.  
키는 기본키,후보키,슈퍼키,대체키,외래키등이 있습니다.  

### 2.1 키의 종류별로 설명하시오  
후보키는 릴레이션에서 튜플을 유일하게 식별할수 있는 키들을 의미합니다. 유일성과 최소성을 만족합니다.  
기본키는 후보키들중 선택한 하나의 키를 의미하고 널값을 가질수 없습니다.
대체키는 후보키에서 기본키를 제외한 키를 의미합니다.  
슈퍼키는 릴레이션에서 튜플을 유일하게 식별할수있는 유일성을 만족하지만 최소성을 만족하지 못하는 키를 의미합니다.  
외래키는 참조하고 있는 릴레이션의 속성이 현재 릴레이션에서는 기본키인 속성을 의미합니다.  

---
# 3.정규화란 무엇입니까 

데이터의 중복으로 발생하는 이상현상을 없애기 위해서 데이터의 중복을 최소화 하는 작업을 의미합니다. 
정규화는 1정규화부터 5정규화까지 존재하고 주로 BCNF정규화까지만 합니다.  
정규화를 할수록 이상현상이 없어진다. 
하지만 join연산이 많이 일어나게 되어서 연산속도가 느려진다는 단점이 있습니다. 

### 3.1정규화의 단계별로 설명하시오  

1정규화는 도메인에 여러 값이 들어가는 것이 아니라 원자값으로 되어있어야합니다. 예를 들어 한사람에 핸드폰번호가 여러개 있으면 원자값이 아닌것이고 핸드폰번호가 한개면 원자값입니다.  
2정규화는 1정규화에 속하고 모든속성이 기본키에 완전 함수 종속이 되어야합니다.  
3정규화는 2정규화에 속하고 이행적함수 종속을 제거해야합니다.  
BCNF정규화는 3정규화에 속하고 모든 결정자가 후보키에 속해야 합니다.  

### 3.2완전함수 종속과 이행적 함수 종속에 대해 설명하시오  

완전함수 종속은 기본키로 모든 튜플을 식별할수 있는 것을 의미합니다.  
기본키가 1개의 속성으로 구성되어있으면 기본키로 식별이 가능하고 2개의 속성이라면 2개 속성을 모두 알아야 튜플을 식별할수 있어야합니다.  
이행적 함수 종속은 A가 B를 식별할수 있고 B가 C를 식별하는 경우를 의미합니다.  

### 3.2이상현상의 종류를 설명하시오 

삽입이상: 데이터를 추가할때 원하는 데이터만 추가하는 것이 아니라 다른 데이터도 같이 추가해줘야해서 발생하는 이상 
삭제이상: 샂게하려는 데이터만 지워지는 것이 아니라 그 이외의 데이터가 같이 삭제되서 발생 
갱신이상: 다른 릴레이션에 존재하는 같은 데이터와 값이 달라져서 일관성이 위배되어서 발생 

### 3.3정규화의 단점은 무엇입니까  
정규화를 할수록 중복이 적어져서 join 연산이 많아져 검색 속도가 느려진다는 단점이 있습니다.  
그래서 성능개선을 위해 일부러 중복을 유도하는 반정규화 기법이 있습니다.  

### 3.4 반정규화에 대해 설명하세요  
데이터베이스의 성능 향상을 위해 의도적으로 정규화 원칙을 위배하는 방법입니다.  
반정규화를 하면 성능이 향상되지만 데이터의 일관성과 정합성이 저하될수 있고 과도한 정규화는 오히려 성능이 저하됩니다.  
반정규화 방법에는 테이블 통합, 테이블 분할, 중복 테이블 추가, 중복 속성 추가등이 있습니다.  

### 3.5 반정규화의 종류에 대해 설명하시오  
테이블 통합은 조인이 많이 발생하는 두개의 테이블을 합치는 것을 의미힙니다.  
테이블 분할은 수직분할과 수평분할로 나뉘게 됩니다.  
우선 수평분할은 레코드 별로 사용빈도 차이가 큰 경우 수평으로 테이블을 분할하는 것이고 수직분할은 속성이 너무 많을 경우 수직으로 분할하는 방법입니다.  
중복 테이블 추가는 여러 테이블에서 데이터를 가져와서 사용할때 중복되는 테이블을 추가해서 사용하는 것입니다.  
마지막으로 중복속성 추가는 조인이 자주발생하거나 접근 경로가 복잡한 경우 속성을 추가하는 방식입니다.  

# 4. 트랜잭션이란 무엇입니까 
작업의 논리적 기본단위이고 작업의 완전성을 보장해주는 것입니다. 하나의 작업을 완전히 처리하지 않으면 기존의 상태로 복구시키는 것을 기능입니다. 
원자성, 일관성, 독립성, 지속성 (ACID)을 만족해야합니다.  
원자성은 연산의 결과가 모든 데이터베이스에 반영이 되거나 전혀 반영되지 말아야 하는 속성을 말합니다.  
일관성은 트랜잭션이 처리 결과가 항상 일관성이 있어야합니다.  
독립성은 하나의 트랜잭션이 수행중일때 다른 트랜잭션이 간섭할수 없는 것을 의미합니다.  
지속성은 트랜잭션이 성공적으로 완료된 경우 결과가 영구적으로 반영되어야 하는 것을 의미합니다.  

### 4.1 트랜잭션 commit, rollback, savepoint에 대해 설명하시오  
우선 commit은 변경된 내용을 디스크에 저장하는 것입니다.  
rollback은 작업을 취소하는 것으로 지정된 시점으로 상태를 복귀시킵니다.  
마지막으로 savepoint는 저장점을 지정하는 것으로 rollback을 사용하여 복귀시킬 시점을 정합니다.  

### 4.2 트랜잭션 격리수준이란 무엇입니까  
특정 트랜잭션이 다른 트랜잭션이 변경한 데이터를 볼 수 있도록 허용할지 말지 결정하는 것입니다.  
트랜잭션 격리 수준은 READ COMMITED, READ UNCOMMITED, REPEATABLE READ, SERIALIZABLE로 나누어집니다.  
  
READ UNCOMMITED는 커밋되지 않은 데이터에도 접근이 가능한 것으로 공유데이터에 접근해도 보호되지 않습니다. 이때 dirty read문제가 발생할수 있습니다.  
dirty read란 공유데이터를 사용한 트랜잭션이 롤백되었을 경우 이전의 값을 그대로 사용하는 것을 의미합니다.  
  
READ COMMITED는 실제 변경된 데이터를 가져오는 것이 아니라 커밋된 데이터를 조회하는 것입니다. 커밋된 데이터만 조회하므로 DIRTY READ가 발생하지 않습니다.
하지만 하나의 트랜잭션이 같은 일을 할때 다른 값을 조회하는 non-repeatable read 문제가 발생할수 있습니다.  
  
REPEATABLE READ는 트랜잭션이 시작되고 종료될때까지 한번 조회한 값은 계속 같은 값이 조회되도록 하는 것입니다.  
이때 업데이트 한 값에는 정합성을 보장하지만 삭제와 삽입은 보장하지 않습니다.  
  
SERIALIZABLE은 트랜잭션이 특정 테이블을 조회하면 다른 트랜잭션은 해당 테이블을 삽입,삭제,변경할수 없는 것을 의미합니다. 다른 말로 로킹제어라고 합니다.  
가장 강력한 격리수준이지만 동시에 처리하는 능력은 가장 떨어진다는 단점이 있습니다.  

### 4.3 트랜잭션의 로킹의 문제는 무엇이고 로킹 단위가 클 경우와 작을 경우의 차이를 설명하시오  
로킹제어를 사용하면 데드락이 발생할수 있다는 문제점도 존재합니다.  
로킹 단위가 크면 관리는 쉽지만 병행성이 떨어집니다.  
하지만 로킹 단위가 작으면 관리가 어렵고 오버헤드가 증가하지만 병행성은 증가하는 장점이 있습니다.  

---

# 5. 시스템 카탈로그란 무엇입니까  
시스템 자체에 관련이 있는 데이터들을 저장하는 시스템 데이터 베이스입니다.  
시스템 카탈로그에 저장되있는 데이터를 메타데이터라고 하고 메타데이터는 일반 사용자가 조회는 가능하지만 삽입,삭제,갱신과 같은 작업은 허용되지 않습니다.  

---

# 6. 무결성이란 무엇입니까?  
무결성이란 데이터의 정확성, 일관성, 유효성을 유지하는 것을 의미합니다.  
개체 무결성, 참조 무결성, 도메인 무결성, 키 무결성 등이 있습니다.  
개체 무결성은 기본키는 널값을 허용하지 않느 것을 의미합니다.  
참조 무결성은 참조 관계에 있는 테이블의 데이터는 항상 같은 값을 유지해야 합니다.  
도메일 무결성은 특정 속성의 값이 도메인에 속한 값이여야 하는 것을 의미합니다. (ex. 성별 속성에는 남,여가 올수 있지만 중성은 올수 없다)  
키 무결성은 하나의 릴레이션에는 반드시 하나의 키가 존재해야 하는 것을 의미합니다.  

### 6.1 무결성은 왜 필요한가요  
무결성이 유지되어야 데이터베이스에 저장된 데이터와 현실 세계의 실제값이 일치하는지 신뢰할수 있기 때문입니다.  

