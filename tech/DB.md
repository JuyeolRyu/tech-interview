# 1.인덱스  
**데이터 값**과 **데이터의 주소**가 같이 저장된 것을 의미합니다.  
데이터의 탐색에는 효율적이지만 데이터 삽입,삭제,수정에는 시간이 더 많이 걸리게 됩니다.  
인덱스 알고리즘은 b+tree, hash 인덱스 알고리즘이 있습니다.  
hash인덱스는 시간복잡도가O(1)이지만 데이터의 일부분으로 검색할수 없어서 범위탐색시에는 오히려 b+tree보다 오래걸린다는 특징이 있습니다.  
  
#### **📝인덱스 단점 발생하는 이유**  
> 인덱스는 데이터&주소가 맵핑되어있고 정렬되어있습니다. 따라서 원하는 데이터가 어떤 주소에 저장되어있는지 알기 때문에 검색속도는 올라가게 됩니다.  
하지만 삽입,삭제,갱신에는 **정렬된 상태를 유지**해서 데이터를 관리하고 인덱스 테이블도 관리해야 하기 때문에 **속도가 느려질수 있습니다**.  

#### **📝인덱스 알고리즘 종류**    
> 인덱스 알고리즘은 **B-tree**,**B+tree** 알고리즘과 **Hash** 알고리즘이 있습니다.  
* B-tree  
> **B-tree**는 **balanced tree**로 정렬된 상태로 유지되고 **노드 전체에 데이터가 저장**되어 있습니다.  
* B+tree  
> B+tree 인덱스는 말그대로 트리형태로 인덱스를 구분해서 나누어 놓은것입니다.  
B+tree의 경우 삽입,삭제 시 자동으로 구조를 유지하기 때문에 **테이블의 구조를 재구성할 필요가 없기** 때문에 사용합니다.  
또한 **범위 탐색시 유리**하다는 장점이 있습니다. 이러한 장점 때문에 대부분의 관계형 DB에서 B+tree를 지원하고 있습니다.  
* Hash  
> 해시는 컬럼 값의 해시값을 계산해서 저장하므로 **검색속도가 빠릅니다**.  
하지만 해시값으로 탐색하므로 **값의 일부분만으로 검색할수 없습니다**.  

👉**B+tree 삽입**  
![image](https://user-images.githubusercontent.com/49298852/140603501-fff2f0f2-85ed-4a86-84f8-2229e345c404.png)
위의 트리에 Adams를 삽입하라.  

👉**B+tree 삭제**  
![image](https://user-images.githubusercontent.com/49298852/140603501-fff2f0f2-85ed-4a86-84f8-2229e345c404.png)  
위의 트리에서 Srinivasan를 삭제하라.  

❗[정답](https://ju-hy.tistory.com/106)  

#### **📝인덱스 종류**   
* primary index(기본인덱스)  
> **기본 인덱스**는 테이블의 **기본키**를 포함하는 인덱스로서 키의 순서가 레코드의 순서를 결정 짓습니다.  
* secondary index(보조인덱스)  
> **보조 인덱스**는 기본키 이외의 인덱스이고 키의 순서가 레코드의 순서를 의미하지 않습니다.  
* 컴포지트 인덱스(Composite)  
> **컴포지트 인덱스**는 인덱스를 생성할때 두개 이상의 컬럼을 합쳐서 생성한 인덱스입니다.  
> 두개 이상의 컴럼을 사용하기 때문에 **and 연산**으로 탐색할때 유리합니다.
* 클러스터드(Clustered) 인덱스  
> **클러스터드 인덱스**는 물리적으로 정렬되어 있는 상태로 데이터가 저장되는 인덱스이고 1개만 생성이 가능합니다.  
기본키 설정 시 **기본키를 기준**으로 클러스터드 인덱스가 생성됩니다.  
인덱스 자체의 **리프 페이지가 데이터**입니다. 이 말은 테이블 자체가 인덱스라는 의미이고 **별도의 인덱스 테이블이 생성되지 않습니다**.  
* 넌클러스터드(Non-Clustered) 인덱스  
> **넌클러스터드 인덱스**는 레코드 **원본은 정렬되어 있지 않고** **인덱스 테이블만 정렬**되어있는 인덱스입니다.  
**클러스터드 인덱스**보다 **검색 속도는 느리지만** **삽입,삭제,변경의 속도는 더 빠릅니다**.  
별도의 인덱스 테이블을 생성하므로 **용량을 추가로 차지**합니다.  
<br/>  
<br/>  
<br/>  

# 2.키  
**키**는 데이터베이스에서 조건을 만족하는 **튜플을 구분할수 있는 속성의 조합**을 의미합니다.  
키는 **기본키**,**후보키**,**슈퍼키**,**대체키**,**외래키**등이 있습니다.  
  
**후보키**는 릴레이션에서 튜플을 유일하게 식별할수 있는 키들을 의미합니다. **유일성**과 **최소성**을 만족합니다.  
**기본키**는 후보키들중 선택한 하나의 키를 의미하고 **널값을 가질수 없습니다**.
**대체키**는 후보키에서 **기본키를 제외한 키**를 의미합니다.  
**슈퍼키**는 릴레이션에서 튜플을 유일하게 식별할수있는 유일성을 만족하지만 **최소성을 만족하지 못하는 키**를 의미합니다.  
**외래키**는 참조하고 있는 릴레이션의 속성이 현재 릴레이션에서는 **기본키**인 속성을 의미합니다.  

#### **📝유일성**    
> **유일성**이란 하나의 키값으로 튜플을 유일하게 식별할수 있는 특성을 의미합니다.  
#### **📝최소성**    
> **최소성**이란 튜플을 유일하게 식별하는 키 값에서 키 값의 모든 속성이 포함되어야 튜플을 식별할수 있는 특성을 의미합니다.
<br/>  
<br/>  
<br/>  

# 3.정규화   
데이터의 **중복으로 발생하는 이상현상**을 없애기 위해서 데이터의 **중복을 최소화** 하는 작업을 의미합니다. 
정규화는 1정규화부터 5정규화까지 존재하고 주로 BCNF정규화까지만 합니다.  
정규화를 할수록 이상현상이 없어진다. 하지만 **join연산이 많이 일어나게** 되어서 **연산속도가 느려진다**는 단점이 있습니다. 
  
**1정규화**는 도메인에 여러 값이 들어가는 것이 아니라 **원자값**으로 되어있어야합니다. 예를 들어 한사람에 핸드폰번호가 여러개 있으면 원자값이 아닌것이고 핸드폰번호가 한개면 원자값입니다.  
**2정규화**는 1정규화에 속하고 모든속성이 기본키에 **완전 함수 종속**이 되어야합니다.  
**3정규화**는 2정규화에 속하고 **이행적함수 종속을 제거**해야합니다.  
**BCNF정규화**는 3정규화에 속하고 **모든 결정자**가 **후보키**에 속해야 합니다. **결정자**란 A->B 관계에서 A가 B의 결정자입니다.  
  
#### **📝완전 함수 종속, 이행적 함수 종속**  
> **완전함수 종속**은 기본키로 모든 튜플을 식별할수 있는 것을 의미합니다.  
기본키가 1개의 속성으로 구성되어있으면 기본키로 식별이 가능하고 2개의 속성이라면 2개 속성을 모두 알아야 튜플을 식별할수 있어야합니다.  
**이행적 함수 종속**은 A가 B를 식별할수 있고 B가 C를 식별하는 경우를 의미합니다.  
  
#### **📝이상현상**  
> **삽입이상**: 데이터를 추가할때 원하는 데이터만 추가하는 것이 아니라 다른 데이터도 같이 추가해줘야해서 발생하는 이상입니다.   
**삭제이상**: 삭제하려는 데이터만 지워지는 것이 아니라 그 이외의 데이터가 같이 삭제되서 발생합니다.   
**갱신이상**: 다른 릴레이션에 존재하는 같은 데이터와 값이 달라져서 **일관성이 위배**되어서 발생입니다.   
  
#### **📝반정규화**  
> 데이터베이스의 성능 향상을 위해 **의도적으로 정규화 원칙**을 위배하는 방법입니다.  
반정규화를 하면 성능이 향상되지만 데이터의 **일관성**과 **정합성**이 저하될수 있고 과도한 정규화는 오히려 **성능이 저하**됩니다.  
반정규화 방법에는 테이블 통합, 테이블 분할, 중복 테이블 추가, 중복 속성 추가등이 있습니다.  
* 테이블 통합  
> **테이블 통합**은 조인이 많이 발생하는 두개의 테이블을 합치는 것을 의미힙니다.  
* 테이블 분할  
> **테이블 분할**은 **수직분할**과 **수평분할**로 나뉘게 됩니다.  
> 우선 **수평분할**은 레코드 별로 사용빈도 차이가 큰 경우 수평으로 테이블을 분할하는 것이고 **수직분할**은 속성이 너무 많을 경우 수직으로 분할하는 방법입니다.  
* 중복 테이블 추가  
> **중복 테이블 추가**는 여러 테이블에서 데이터를 가져와서 사용할때 중복되는 테이블을 추가해서 사용하는 것입니다.  
* 중복 속성 추가  
> 마지막으로 **중복속성 추가**는 조인이 자주 발생하거나 접근 경로가 복잡한 경우 속성을 추가하는 방식입니다.  
<br/>  
<br/>  
<br/>  

# 4. 트랜잭션  
트랜잭션이란 작업의 논리적 기본단위이고 **작업의 완전성을 보장**해주는 것입니다. 하나의 작업을 완전히 처리하지 않으면 기존의 상태로 복구시키는 특징이 있습니다.  
트랜잭션은 **원자성, **일관성**, **독립성**, **지속성** (ACID)을 만족해야합니다.  
**원자성**은 연산의 결과가 모든 데이터베이스에 반영이 되거나 전혀 반영되지 말아야 하는 속성을 말합니다.  
**일관성**은 트랜잭션이 처리 결과가 항상 일관성이 있어야합니다.  
**독립성**은 하나의 트랜잭션이 수행중일때 다른 트랜잭션이 간섭할수 없는 것을 의미합니다.  
**지속성**은 트랜잭션이 성공적으로 완료된 경우 결과가 **영구적으로 반영**되어야 하는 것을 의미합니다.  
  
ex) A은행에서 B은행으로 송금을 해야하는 경우
    만약 송금 도중에 A은행의 계좌에서는 돈이 빠져나가고 B은행의 계좌에는 돈이 입금되지 않는 문제가 발생했습니다.
    이러한 경우 송금이 완전히 이루어지거나 아예 없던 거래로 처리하기 위해 트랜잭션이 존재하는 것입니다.  
#### **📝트랜잭션 연산**  
> **트랜잭션의 연산**은 **Commit**,**Savepoint**,**Rollback**으로 구성되어있습니다.  
> 우선 **Commit**의 경우 변경된 내용을 디스크에 저장하는 연산입니다.  
> **Savepoint**는 rollback할 지점을 정하는 연산입니다.  
> **Rollback**은 변경된 내용을 취소하고 이전 지점이나 저장된 지점으로 복귀시키는 연산입니다.  

#### **📝트랜잭션 격리수준**  
> 특정 트랜잭션이 다른 트랜잭션이 변경한 데이터를 볼 수 있도록 허용할지 말지 결정하는 것입니다.  
트랜잭션 격리 수준은 **READ UNCOMMITED**, **READ COMMITED**, **REPEATABLE READ**, **SERIALIZABLE**로 나누어집니다.  
* READ UNCOMMITED  
> **READ UNCOMMITED**는 커밋되지 않은 데이터에도 접근이 가능한 것으로 공유데이터에 접근해도 보호되지 않습니다. 이때 **Dirty read**문제가 발생할수 있습니다.  
**Dirty read**란 변경되었지만 커밋하지 않은 공유데이터를 다른 트랜잭션이 사용했는데 트랜잭션이 롤백되었을 경우 롤백 이전의 값을 그대로 사용하는 것을 의미합니다.  
* READ COMMITED    
> **READ COMMITED**는 실제 변경된 데이터를 가져오는 것이 아니라 **커밋된 데이터를 조회**하는 것입니다. 커밋된 데이터만 조회하므로 **DIRTY READ가 발생하지 않습니다**.  
하지만 하나의 트랜잭션이 같은 일을 할때 다른 값을 조회하는 **non-repeatable read** 문제가 발생할수 있습니다.  
**non-repeatable read**는 하나의 트랜잭션내에서 항상 같은 결과를 반환해야하는 원칙을 위반하는 문제입니다.  
만약 B트랜잭션이 1이라는 데이터를 조회하면 1이 반환됩니다. 그리고 A트랜잭션이 1을 2로 변경합니다. B트랜잭션이 다시 1을 조회하면 2가 반환됩니다.  
* REPEATABLE READ  
> **REPEATABLE READ**는 트랜잭션이 시작되고 종료될때까지 한번 조회한 값은 계속 같은 값이 조회되도록 하는 것입니다. 트랜잭션이 시작되기 전 커밋 상태만 조회하는 것입니다.  
이때 업데이트 한 값에는 정합성을 보장하지만 **삭제와 삽입은 보장하지 않습니다**.   
* SERIALIZABLE  
> **SERIALIZABLE**은 트랜잭션이 특정 테이블을 조회하면 **다른 트랜잭션은 해당 테이블을 삽입,삭제,변경할수 없는 것**을 의미합니다. 다른 말로 **로킹제어**라고 합니다.  
가장 강력한 격리수준이지만 **동시에 처리하는 능력은 가장 떨어진다**는 단점이 있습니다.  

#### **📝트랜잭션 로킹**  
> 트랜잭션 로킹이란 트랜잭션이 데이터에 접근할때 다른 트랜잭션이 접근하지 못하도록 하는 기법입니다.  
로킹제어를 사용하면 **데드락**이 발생할수 있다는 문제점도 존재합니다.  
이때 로킹 단위가 크면 **관리는 쉽지만 병행성이 떨어집니다**. 하지만 로킹 단위가 작으면 **관리가 어렵고 오버헤드가 증가**하지만 **병행성은 증가**하는 장점이 있습니다.  
<br/>  
<br/>  
<br/>  

# 5. 시스템 카탈로그  
시스템 자체에 관련이 있는 데이터들을 저장하는 **시스템 데이터 베이스**입니다.  
시스템 카탈로그에 저장되있는 데이터를 **메타데이터**라고 하고 메타데이터는 일반 사용자가 **조회는 가능**하지만 **삽입,삭제,갱신과 같은 작업은 허용되지 않습니다**.  
<br/>  
<br/>  
<br/>  

# 6. 무결성,정합성?  
**무결성**이란 데이터값이 정확하고 완전해야하는 속성입니다. 무결성이 유지되어야 데이터와 실제값이 일치하는지 신뢰할수 있습니다.  
무결성의 종류는 **개체 무결성**, **참조 무결성**, **도메인 무결성**, **키 무결성** 등이 있습니다.  
* 개체 무결성  
> **개체 무결성**은 기본키는 널값을 허용하지 않는 것입니다.  
* 참조 무결성  
> **참조 무결성**은 참조 관계에 있는 테이블의 **데이터는 항상 같은 값을 유지하거나 Null**이여야 합니다.  
* 도메인 무결성  
> **도메인 무결성**은 특정 속성의 값이 **도메인에 속한 값**이여야 하는 것을 의미합니다. (ex. 성별 속성에는 남,여가 올수 있지만 중성은 올수 없다)  
* 키 무결성  
> **키 무결성**은 하나의 릴레이션에는 **반드시 하나의 키가 존재**해야 하는 것을 의미합니다.  
  
**정합성**이란 데이터들의 값이 서로 일치해야하는 속성입니다. 중복 데이터를 많이 사용하면 정합성을 맞추기 어렵습니다.  
비정규형을 사용할때 이상현상이 발생하고 이때 정합성이 위배될수 있습니다.  
<br/>  
<br/>  
<br/>  

# 7. NoSQL  
**NoSQL**이란 관계형 데이터 베이스의 한계를 극복하기 위한 새로운 데이터 저장소의 형태입니다.  
key-value 형식을 지원하고 관계를 정의하지 않습니다. 그리고 읽기,쓰기의 성능이 RDBMS에 비해 빠릅니다.  
**고정된 스키마가 없고 수평확장에 유리**합니다. 또한 빅데이터,분산환경에서 대용량의 데이터를 처리하기 유리합니다.  
  
#### **📝NoSQL 데이터 모델**  
* key/value 데이터베이스   
> key와 value로 구성된 데이터 모델입니다. 단순한 저장구조를 가지고 빠르게 읽고 쓸수 있습니다.  
* Big Table 데이터베이스  
> key/value와 데이터 저장방식을 같습니다.  
> 보통의 NoSQL은 정렬기능을 제공하지 않지만 Big Table 데이터베이스은 key를 기준으로 정렬합니다.  
* Document 데이터베이스  
> key/value에서 확장된 형태입니다. value에 document타입을 받습니다.(XML,JSON)  
> 복잡한 데이터 구조를 표현할수 있고 document id 또는 속성값으로 인덱스를 생성하므로 sorting,join이 가능합니다.  
* Graph 데이터베이스  
> 노드들과 관계로 구성된 데이터베이스입니다.  
