## **운영체제**

---

### **1.프로세스와스레드의차이에대해설명하시오.**

프로세스는 메모리에적재되어 실행중인 프로그램을 의미합니다. 운영체제로부터 자원을 할당받는 작업의 단위입니다.
각각의 프로세스는 독립적으로 동작하며 다른 프로세스의 자원에접근할수없습니다. 각각의 프로세스간 데이터를 교환하기 위해서는 `IPC(Inter Process Comunication)`을 사용해야 한다.

스레드란 프로세스의 실행 단위입니다. 하나의 프로세스에서 여러개의 스레드가 동작할수있습니다. 
각각의 스레드는 힙,데이터,코드 영역을 공유하고 각각의 스택을 가집니다.
스레드간 공유메모리를 가지기 때문에 데이터 전송과 `Context Switch`에 많은 비용이 발생하지 않는다.
스택을 제외한 메모리를 공유해서 사용하므로 하나의 스레드의 공유 메모리 영역에 손상이 생기면 전체의 스레드가 동작하지 않는 단점이 있습니다.

---

### **1.1 프로세스의 주소공간 할당에 대해 설명하고 각각 어떤 데이터가 저장되는지설명하시오**

Code: 코드자체가 저장됩니다.

Data:전역변수,정적변수,배열과같은 데이터가 저장됩니다.

Heap: 동적 데이터가 저장됩니다.

Staack:지역변수,매개변수, 함수가 저장됩니다.

---

### **1.2멀티프로세스와멀티스레드를설명하고 차이점에 대해설명하시오**

멀티프로세스란 여러개의 프로세스가 동작하는 것을 의미합니다.Fork를통해 부모프로세스에서 자식프로세스가 생성이 되는데 각각의 프로세스들은 독립적인 메모리 영역을 가집니다. 하지만 `Contextswitch`로인해 성능 저하가 발생합니다.

멀티스레드는 하나의 프로세스에서 여러개의 스레드가 동작하는 것을 의미합니다. 또한 멀티스레드는 스택영역을제외하고 메모리를 공유하기 때문에 자원손실을 줄일 수 있습니다. 하지만 하나의 스레드가 공유메모리공간을 망치면 다른 스레드들도 동작이되지 않는다는 단점이 있습니다.

---

### **1.3 context스위치란 무엇이고 어떤 과정을 가지는지설명하시오**

다른 프로세스를 실행하고자할때 현재 실행중인 task의 상태를 저장하고 다른 task의 상태를 복원하는 과정을 의미합니다.

실행중인 task의 context를 PCB에 저장하고 다음 실행할 task의 context를 읽어서 레지스터에 저장합니다.

---

### **1.4 PCB란무엇이고왜 필요한지**

`PCB`는 `Process manage block`의 약자로 프로세스의 메타데이터를 저장해놓습니다.

Cpu에서는 여러 프로세스들이 번갈아 가면서 실행이 되는데 이때 프로세스의 이전 상태를 기억해두기 위해서 `PCB`를사용하게 됩니다.

---

### **2.인터럽트란 무엇이고 어떻게동작하는가**

프로그램 실행 도중에 우선적으로 처리해야할 작업이 생길 경우 먼저 처리하고 기존의 작업을 처리하는 것을 인터럽트라고 합니다.

인터럽트는 `외부인터럽트`,`내부인터럽트`,`소프트웨어인터럽트가 있습니다. 
외부인터럽트는 입출력 장치등에서 오는 외부적요인으로 발생합니다.
내부인터럽트는 내부에서 오류가발생했을때(0으로나누기 ,버퍼오버플로우...) 발생합니다.
소프트웨어 인터럽트는 프로그램 처리중에 발생하는 것을 의미한다.

---

### **3.시스템콜이란무엇인가**

커널 영역의 기능을 사용자 모드에서사용가능하도록해줍니다.
다시말해 프로세스가 하드웨어에 직접 접근하여 필요한 기능을 사용할수 있게 해주는 것을 의미합니다.

---

### **4.시스템콜 명령어의 종류를 말하고설명하시오**

Fork(): 자식프로세스를 생성하는 시스템콜

Wait():child가끝날때까지기다리는 시스템콜

Exec():fork해온기존 프로세스와 다른 기능을 하도록 하게 해주는 시스템콜

---

### **5.IPC란무엇이고 어떤 종류가있는가**

프로세스간 통신을 가능하도록 해주는 것이 IPC(interprocesscommunication)이다.

익명파이프 : 통신할 프로세스를 명확히 알고 있는 경우 사용합니다.

한쪽방향으로만 통신이 가능한반이중통신입니다.

                 간단하게사용할수있다는 장점이 있지만전이중통신을위해 2개를만들어야하면복잡해진다는 단점이 있습니다.

네임드파이프 : 전혀 모르는 프로세스간 통신에 사용됩니다.

네임드파이프도 익명파이프처럼반이중통신입니다.

메시지큐 : 파이프처럼 데이터의 흐름이 아니라 메모리에번호를 붙인 데이터를 적재하는 것을 의미합니다.

공유메모리 :데이터를공유가능하도록 해주는 것입니다. 스레드처럼 메모리를 공유하는 것입니다.

                 중개자 없이 바로 메모리에 접근이 가능하므로IPC중가장 빠릅니다.

메모리맵 : 공유메모리처럼메모리를공윻ㅂ니다파일을 메모리에맵핑시켜서공유하는 방식입니다.

               대용향의 데이터를공유할때사용합니다.

소켓 : 클라이언트와 서버가 소켓을 사용해서 통신하는 구조입니다.

---

### **5.1 IPC는왜필요한가**

각각의 프로세스는 독립적으로 동작한다. 이때 독립적인 프로세스간 데이터 통신을 위해서IPC가필요하다.

---

### **6.스케줄링은무엇인가**

Cpu나자원을 효율적으로 사용하기 위해 프로세스를cpu에할당하는 순서를 정해주는 것을 의미합니다. 많은처리량,빠른응답시간,deadline맞추는것이 목표입니다.  
크게는 장기,중기,단기 스케줄러로 구분하고 cpu 점유 탈취 가능 여부로 선점형 스케줄러와 비선점형 스케줄러로 구분됩니다.
  
장기 스케줄러는 스케줄러 큐에 적재할 task를 선정하는 것이 목표입니다.  
단기 스케줄러는 장기스케줄러로 선택한 task들의 우선순위를 결정해줍니다. 선점형,비선점형 스케줄러가 이에 속합니다.  
마지막으로 중기 스케줄러는 우선순위가 낮은 task를 스케줄링 큐에서 내리는 역할을 합니다.  
현재 사용되는 스케줄러는 단기 스케줄러만 사용됩니다.  

---

### **6.1선점형 스케줄러와 비선점형 스케줄러의 차이는무엇입니까**

선점형 스케줄러는 우선순위를 가지고 실행되며 제한된 시간을 가지고 있습니다. 우선순위가 존재함으로특정task가 자원을할당받지못하는 기아현상(starvation)이발생할 수있습니다.또한 문맥교환이 자주일어날수있음으로 오버헤드가발생할수있습니다.

비선점형 스케줄러는 프로세스가 종료되지 않는 이상 자원을 반납하지 않습니다. 정해진 순서대로 프로세스가 처리되기 때문에 오버헤드가 없고 기아상태에 빠질 일도 없습니다.

이러한 차이 때문에선점형시스템은대화형 시스템에 많이 사용되고비선점형시스템은일괄처리되는배치시스템에 사용됩니다.

---

### **6.2비선점형 스케줄러를 말하고설명하시오**

FCFS: 먼저 큐에 들어간 순서대로 처리합니다
SJF: 가장 짧은 수행시간을 가지는 작업을 먼저 처리합니다.

---

### **6.3선점형 스케줄러를 말하고설명하시오**

SRTF: sjf 알고리즘에 선점형 스케줄링 기법을 추가한것입니다. 남은 시간이 가장 작은 task가 우선순위가 높습니다.  
Priority스케줄링:우선순위가 높은순서대로처리되는데 우선순위가 동적으로변할수있습니다. 따라서 기아현상이발생할수있는데에이징기법을사용해서해결할수있습니다.  
라운드로빈 : 각각의 프로세스마다timequantum을할당해서timequantum만큼 실행하고 다음 프로세스를 실행하는 방식입니다. 문맥교환이 자주 발생해서 오버헤드가 발생합니다.  
Multilevel-queue(멀티레벨큐) : 큐를여러개사용하는 방식입니다.라운드로빈처럼timequantum이주어지고timequantum만큼실행하고 다 실행되지 않았으면 우선순위가 낮은 다음 큐로 내려가게 됩니다.
짧은 작업을처리할때유리하고,turnarround평균시간을 줄여줍니다.  
멀티레벨피드백큐:멀티레벨큐에서기아상태에 빠지는 것을 방지하기 위해에이징기법을 추가한 스케줄링 기법입니다.  

---

### **6.4에이징 기법이란무엇입니까**

특정 프로세스의 우선순위가 낮아서 무한정 기다리는 경우를 방지하기 위해서 기다린 시간에 비례해서 우선순위를 높여주는 방법입니다.

Sjf+에이징\==> HRN

멀티레벨큐+에이징  ==>멀티레벨피드백큐

---

### **7.데드락은무엇입니까?**

프로세스가 특정 자원을얻지못해서다음 처리를 하지 못하는 상태를 의미하고 교착상태라고도 부릅니다.

상호배제,점유대기,비선점,순환대기 모두충족할때발생합니다.

상호배제: 한자원에 여러 프로세스가 동시에접근할수없는 것을 의미합니다.

점유와대기: 자원을 가지고 있는 상태에서 다른 프로세스가 사용하는 자원의반납을 기다리는 것을 의미합니다.

비선점: 다른 프로세스의 자원을가져올수없는 것을 의미합니다.

환형대기: 각각의 프로세스가 다음 프로세스가 원하는 자원을 가지고 있는 상태를 의미합니다.

---

### **7.1 교착상태 해결방법은무엇이있습니까**

예방,회피,회복,무시4가지가 있습니다

예방: 교착상태 발생조건중하나를 제거해서 해결합니다. 자원낭비가 크다는 단점이 있습니다.

회피:교착상태가 발생하지 않도록 회피하는 방법입니다. 은행원 알고리즘과 자원할당 알고리즘이 있습니다.

탐지&회복: 교착상태가 되도록 허용하고 교착상태를 제거하는 방법입니다. 교착상태를 탐지하고 프로세스를 모두 제거하거나 하나씩 제거하는 방법을 사용합니다.

---

### **7.2 은행원 알고리즘에 대해설명하시오**

안전상태를유지할수있는 요구만 수락하고 불안전 상태를유발할수있는 요구는 거절하는 방법입니다.

---

### **7.3자원할당 알고리즘에 대해설명하시오**

---

# **8.경쟁상태(racecondition)은무엇입니까**

공유자원에 여러 프로세스가 접근해서 데이터의 일관성을해칠수있는 상태를 의미합니다.

### **8.1 경쟁상태가 발생할수 있는경우는 무엇이있습니까**  
커널에서 작업을 수행할때 인터럽트가 발생하면 경쟁상태가 발생할수 있습니다. 이때 커널에서 작업중일때 인터럽트가 발생하지 않도록 disable해놓으면 해결됩니다. 
프로세스가 커널에서 작업중일때 문맥교환이 발생하면 경쟁상태가 발생합니다. 이떄도 커널모드에서 작업중이면 문맥교환이 발생하지 않도록 하면 해결됩니다. 
공유메모리 내의 커널데이터에 여러개의 프로세스가 접근하면 발생합니다. 한 프로세스가 공유데이터에 접근할때 lock을 걸어서 다른 프로세스가 접근하지 못하도록 하면 해결됩니다. 

### 8.2 동시에 공유자원에 접근하면 발생하는 문제를 해결하기 위한 방법은 무엇이 있나요  
첫번째 방법으로 세모포어가 있습니다. 프로세스가 공유자원(임계영역)에 접근하면 세마포어를 감소하고 사용하지 않으면 세마포어를 증가시킵니다. 따라서 세마포어가 0이 되면 가용할수 있는 자원이 없기 때문에 더이상 접근할수 없습니다.  
이때 가용할수 있는 자원의 수가 2개 이상이면 카운팅 세마포어 1개라면 이진 세마포어(뮤텍스)라고 부릅니다.  
    
두번째는 뮤텍스입니다. 동시에 임계영역에 접근할수 있는 스레드가 1개이고 접근할때 lock을 걸고 사용 후에 unlock을 해서 접근을 제어합니다.  
뮤텍스 알고리즘은 데커,피터슨,제과점 알고리즘으로 나뉩니다.  
데커 알고리즘은 flag로 임계영역점근 여부를 정하고 turn으로 누가 접근할 차례인지 판단합니다.  
피터슨 알고리즘은 데커와 유사하지만 임계영역 접근 순서를 양보하는 것이 차이입니다.  
마지막으로 제과점 알고리즘은 가장 적은 수의 표를 가지고 있는 프로세스가 임계영역에 접근하는 방법입니다.  

---

# 9.메모리 관리 기법  
### 9.1 메모리 관리 기법 중 연속 메모리 관리 기법에 대해 설명하시오  
연속 메모리 관리 기법은 프로그램 전체가 하나의 커다란 메모리에 연속적으로 할당되는 것입니다.  
연속 메모리 관리 기법은 고정분할,동적분할 기법으로 나뉩니다.  
고정분할 기법은 말그대로 고정된 크기로 분할하는 것인데 내부 단편화가 발생합니다.  
동적분할 기법은 파티션이 분할되는 크기가 동적입니다. 외부 단편화가 발생합니다.  

### 9.2 내부 단편화와 외부 단편화에 대해 설명하시오  
내부 단편화는 고정 크기 파티션을 할당했을때 해당 크기를 다 사용하지 못해서 발생하는 단편화입니다.  
외부 단편화는 동적 크기 파티션을 할당했을때 메모리 전체에서 남는 메모리가 생기는 것을 의미합니다.  

### 9.3 불연속 메모리 관리 기법에 대해 설명하시오  
불연속 메모리 관리 기법은 프로그램의 일부가 서로다른 주소에 할당되는 것입니다.  
불연속 메모리 관리 기법은 페이징(고정),세그멘테이션(동적)으로 나뉩니다.  
단순 페이징은 고정된 크기로 할당하여 내부 단편화는 있지만 외부 단편화는 발생하지 않습니다.  
단순 세그멘테이션은 메모리를 동적분할해서 프로세스를 할당하므로 메모리 사용효율이 증가하고 오버헤드가 감소합니다. 하지만 여전히 외부 단편화는 존재합니다.  
가상 메모리 페이징은 프로세스를 전부 메모리에 올려서 사용하느 것이 아니라 필요한 페이지가 생기면 로드하는 방식입니다. 필요할때마다 로드해야 하므로 오버헤드가 발생합니다.  
가상 메모리 세그멘테이션 또한 필요할때 마다 메모리로 로드하므로 오버헤드가 발생합니다.  

---

# 10. 엔디안이란 무엇입니까  
컴퓨터 메모리에 연속된 바이트를 할당하는 방법입니다.  

### 10.1 리틀엔디안과 빅엔디안의 차이를 설명하시오  
우선 빅엔디안은 사람들이 평소에 읽는 방식과 유사합니다.(디버깅 유리)  
최상위 비트가 앞에오므로 낮은 주소에 앞의 값이 오게됩니다.  
  
리틀엔디안은 빅엔디안과 읽는 순서가 반대입니다.  
최상위 비트가 가장 뒤에오고 최하위 비트가 가장 앞에오게됩니다.  
이러한 점 덕분에 수가 커지더라도 오버헤드가 발생하지 않습니다.  
