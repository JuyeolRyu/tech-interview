## **운영체제**

---

### **1.프로세스와스레드의차이에대해설명하시오.**

**프로세스**는 메모리에적재되어 실행중인 프로그램을 의미합니다. 운영체제로부터 자원을 할당받는 작업의 단위입니다.  
각각의 프로세스는 독립적으로 동작하며 다른 프로세스의 자원에접근할수없습니다. 각각의 프로세스간 데이터를 교환하기 위해서는 `IPC(Inter Process Comunication)`을 사용해야 한다.  
프로세스는 공유하는 메모리가 없기 때문에 기존의 캐시와 상관없는 데이터를 탐색해야 하기 때문에 `Context Switch`에 많은 비용이 발생합니다.  
  
**스레드**란 프로세스의 실행 단위입니다. 하나의 프로세스에서 여러개의 스레드가 동작할수있습니다. 
각각의 스레드는 힙,데이터,코드 영역을 공유하고 각각의 스택을 가집니다.  
스레드간 공유메모리를 가지기 때문에 데이터 전송과 `Context Switch`에 많은 비용이 발생하지 않습니다.  

스택을 제외한 메모리를 공유해서 사용하므로 하나의 스레드의 공유 메모리 영역에 손상이 생기면 전체의 스레드가 동작하지 않는 단점이 있습니다.  

---

### **1.1 프로세스의 주소공간 할당에 대해 설명하고 각각 어떤 데이터가 저장되는지설명하시오**

Code: 코드자체가 저장됩니다.

Data:전역변수,정적변수,배열과같은 데이터가 저장됩니다.

Heap: 동적 데이터가 저장됩니다.

Staack:지역변수,매개변수, 함수가 저장됩니다.

---

### **1.2멀티프로세스와멀티스레드를설명하고 차이점에 대해설명하시오**

멀티프로세스란 여러개의 프로세스가 동작하는 것을 의미합니다.  
Fork를통해 부모프로세스에서 자식프로세스가 생성이 되는데 각각의 프로세스들은 독립적인 메모리 영역을 가집니다.  
하지만 `Contextswitch`로인해 성능 저하가 발생한다는 단점이 있지만 멀티스레드에 비해 안정성이 높다는 장점이 있습니다.  

멀티스레드는 하나의 프로세스에서 여러개의 스레드가 동작하는 것을 의미합니다.  
또한 멀티스레드는 스택영역을제외하고 메모리를 공유하기 때문에 자원손실을 줄일 수 있다는 장점이 있습니다.    
하지만 하나의 스레드가 공유메모리공간을 망치면 다른 스레드들도 동작이되지 않는다는 단점이 있습니다.  

---

### **1.3 context스위칭란 무엇이고 어떤 과정을 가지는지설명하시오**

cpu는 한번에 하나의 프로세스만 실행 가능합니다.  
이때 최대한 동시에 프로세스들이 실행되는 것처럼 보이게 할때 context switching 을 사용합니다.  

다른 프로세스를 실행하고자할때 현재 실행중인 task의 상태를 PCB에 저장하고 다른 task의 상태를 복원해 레지스터에 저장하는 과정을 거칩니다.  

---

### **1.4 PCB란무엇이고왜 필요한지**

`PCB`는 `Process manage block`의 약자로 프로세스의 메타데이터를 저장해놓습니다.

Cpu에서는 여러 프로세스들이 번갈아 가면서 실행이 되는데 이때 프로세스의 이전 상태를 기억해두기 위해서 `PCB`를사용하게 됩니다.

---

### **2.인터럽트란 무엇이고 어떻게동작하는가**

프로그램 실행 도중에 우선적으로 처리해야할 작업이 생길 경우 먼저 처리하고 기존의 작업을 처리하는 것을 인터럽트라고 합니다.

인터럽트는 `외부인터럽트`,`내부인터럽트`,`소프트웨어인터럽트`가 있습니다. 
외부인터럽트는 입출력 장치등에서 오는 외부적요인으로 발생합니다.  
내부인터럽트는 잘못된 명령이나 데이터를 사용했을때 (0으로나누기 ,버퍼오버플로우...) 발생합니다.  
소프트웨어 인터럽트는 사용자가 다른 프로세스를 실행시키거나 감시 프로그램을 호출할때 발생한다.  

동작과정  
인터럽트 요청-현재 실행중인 명령 완료-PCB에 현재 프로그램 상태를 저장-인터럽트가 발생한 요청을 찾아 해당 요청을 처리-PCB에서 기존 프로그램 상태를 복원-프로그램 실행을 재개

---

### **3.시스템콜이란무엇인가**

커널 영역의 기능을 사용자 모드에서사용가능하도록해줍니다.
다시말해 프로세스가 하드웨어에 직접 접근하여 필요한 기능을 사용할수 있게 해주는 것을 의미합니다.

---

### **4.시스템콜 명령어의 종류를 말하고설명하시오**

Fork(): 자식프로세스를 생성하는 시스템콜

Wait():child가끝날때까지기다리는 시스템콜

Exec():fork해온기존 프로세스와 다른 기능을 하도록 하게 해주는 시스템콜

---

### **5.IPC란무엇이고 어떤 종류가있는가**

프로세스간 통신을 가능하도록 해주는 것이 IPC(interprocesscommunication)이다.

- 익명파이프  
통신할 프로세스를 명확히 알고 있는 경우 사용합니다.(=> 같은 부모 프로세스를 가진 경우)  
한쪽방향으로만 통신이 가능한 반이중통신입니다.  
간단하게 사용할수 있다는 장점이 있지만 전이중통신을 위해 2개의 파이프를 만들어야 한다는 단점이 있습니다.

- 네임드파이프
전혀 모르는 프로세스간 통신에 사용됩니다. 익명파이프의 확장버전입니다.  
그 외의 다른 기능들은 익명파이프와 동일합니다.

- 메시지큐
파이프처럼 데이터의 흐름이 아니라 메모리에 번호를 붙인 데이터를 적재하는 방법입니다.  
또한 파이프와 같이 단방향 통신을 지원합니다.  

- 공유메모리
프로세스간 메모리를 공유해서 사용하는 것을 의미합니다.  
공유메모리는 처음 사용할때만  시스템콜을 사용하고 중개자 없이 바로 메모리에 접근이 가능하므로 `IPC`중 가장 빠릅니다.  
하지만 데이터의 일관성을 유지해야 하기 때문에 동기화가 중요합니다.  

- 메모리맵
메모리맵 또한 `공유메모리`처럼 메모리를 공유합니다.  
다른점은 파일을 열고 메모리에 맵핑 시켜서 공유하는 방식입니다.  
대용량의 데이터를 공유할 때 사용합니다.

- 소켓
클라이언트와 서버가 소켓을 사용해서 통신하는 구조입니다.

---

### **5.1 IPC는왜필요한가**

각각의 프로세스는 독립적으로 동작한다. 이때 독립적인 프로세스간 데이터 통신을 위해서IPC가필요하다.  

---

### **6.스케줄링은무엇인가**

Cpu나 자원을 효율적으로 사용하기 위해 프로세스를 cpu에할당하는 순서를 정해주는 것을 의미합니다. 많은처리량,빠른응답시간,deadline맞추는것이 목표입니다.  
크게는 장기,중기,단기 스케줄러로 구분하고 cpu 점유 탈취 가능 여부로 선점형 스케줄러와 비선점형 스케줄러로 구분됩니다.
  
장기 스케줄러는 스케줄러 큐에 적재할 task를 선정하는 것이 목표입니다.  
단기 스케줄러는 장기스케줄러로 선택한 task들의 우선순위를 결정해줍니다. 선점형,비선점형 스케줄러가 이에 속합니다.  
마지막으로 중기 스케줄러는 우선순위가 낮은 task를 스케줄링 큐에서 내리는 역할을 합니다.  
현재 사용되는 스케줄러는 단기 스케줄러만 사용됩니다.  

---

### **6.1선점형 스케줄러와 비선점형 스케줄러의 차이는무엇입니까**
 
선점형 스케줄러는 우선순위를 가지고 실행되며 제한된 시간을 가지고 있습니다. 우선순위가 존재함으로 특정task가 자원을 할당받지 못하는 기아현상(starvation)이 발생할 수있습니다.또한 문맥교환이 자주 일어날수 있음으로 오버헤드가발생할수있습니다.

비선점형 스케줄러는 프로세스가 종료되지 않는 이상 자원을 반납하지 않습니다. 정해진 순서대로 프로세스가 처리되기 때문에 오버헤드가 없고 기아상태에 빠질 일도 없습니다.

이러한 차이 때문에 선점형 스케줄링은 대화형 시스템에 많이 사용되고 비선점형 스케줄링은 일괄처리 되는 배치시스템에 사용됩니다.

---

### **6.2비선점형 스케줄러를 말하고설명하시오**

FCFS: 먼저 큐에 들어간 순서대로 처리합니다
SJF: 가장 짧은 수행시간을 가지는 작업을 먼저 처리합니다.

---

### **6.3선점형 스케줄러를 말하고설명하시오**

SRTF: sjf 알고리즘에 선점형 스케줄링 기법을 추가한것입니다. 남은 시간이 가장 작은 task가 우선순위가 높습니다.  
Priority스케줄링: 우선순위가 높은 순서대로 처리되는데 우선순위가 동적으로변할수있습니다. 따라서 기아현상이 발생할 수 있는데 에이징기법을 사용해서 해결할수있습니다.  
라운드로빈 : 각각의 프로세스마다 timequantum을 할당해서timequantum만큼 실행하고 다음 프로세스를 실행하는 방식입니다. 문맥교환이 자주 발생해서 오버헤드가 발생합니다.  
Multilevel-queue(멀티레벨큐) : 큐를 여러개 사용하는 방식입니다.라운드로빈처럼 timequantum이 주어지고 timequantum만큼실행하고 다 실행되지 않았으면 우선순위가 낮은 다음 큐로 내려가게 됩니다.
짧은 작업을 처리할때 유리하고,turnarround평균시간을 줄여줍니다.  
멀티레벨피드백큐: 멀티레벨큐에서 기아상태에 빠지는 것을 방지하기 위해 에이징기법을 추가한 스케줄링 기법입니다.  

---

### **6.4에이징 기법이란무엇입니까**

특정 프로세스의 우선순위가 낮아서 무한정 기다리는 경우를 방지하기 위해서 기다린 시간에 비례해서 우선순위를 높여주는 방법입니다.

Sjf+에이징==> HRN

멀티레벨큐+에이징  ==>멀티레벨피드백큐

---

### **7.데드락은무엇입니까?**

프로세스들이 서로의 자원을 반환하기 기다리고 있는 상태를 의미합니다.

프로세스가 특정 자원을얻지못해서다음 처리를 하지 못하는 상태를 의미하고 교착상태라고도 부릅니다.

상호배제,점유대기,비선점,순환대기 모두충족할때발생합니다.

상호배제: 한자원에 여러 프로세스가 동시에접근할수없는 것을 의미합니다.

점유와대기: 자원을 가지고 있는 상태에서 다른 프로세스가 사용하는 자원의반납을 기다리는 것을 의미합니다.

비선점: 다른 프로세스의 자원을 가져올수 없는 것을 의미합니다.

환형대기: 각각의 프로세스가 다음 프로세스가 원하는 자원을 가지고 있는 상태를 의미합니다.

---

### **7.1 교착상태 해결방법은무엇이있습니까**

예방,회피,회복,무시4가지가 있습니다

예방: 교착상태 발생조건중 하나를 제거해서 해결합니다. 자원낭비가 크다는 단점이 있습니다.

회피: 교착상태가 발생하지 않도록 회피하는 방법입니다. 은행원 알고리즘과 자원할당 알고리즘이 있습니다.

탐지&회복: 교착상태가 되도록 허용하고 교착상태를 제거하는 방법입니다. 교착상태를 탐지하고 프로세스를 모두 제거하거나 하나씩 제거하는 방법을 사용합니다.

---

### **7.2 은행원 알고리즘에 대해설명하시오**

안전상태를유지할수있는 요구만 수락하고 불안전 상태를유발할수있는 요구는 거절하는 방법입니다.  
안전상태란 시스템이 교착상태를 일으키지 않고 각 프로세스가 요구하는 자원을 할당할수 있는 상태를 의미합니다.  
반대로 불안전상태란 시스템이 교착상태를 일으킬 가능성이 있는 상태입니다. 또한 각 프로세스가 요구한 양만큼 자원을 할당할수 없는 경우입니다.  
  
은행원 알고리즘이 수행되기 위해서는 각각의 프로세스가 필요로하는 최대 자원의 양, 그리고 각 프로세스가 사용하고 있는 자원의 양, 마지막으로 사용가능한 자원의 양을 알아야 합니다.
예를 들면 12개의 자원을 보유하고 있고 프로세스 3개가 각각 10,9,9개의 자원을 요구하는 상황입니다.  
그리고 a,b,c 프로세스에 자원을 1,2,6개씩 할당합니다.
여기서 a나b 프로세스에 추가적으로 자원을 할당하는 경우는 불안전 상태를 유발할수 있으므로 거절하고 c에서 요청하는 자원을 할당하는 것은 안전상태이므로 허가해주게됩니다.  

---

# **8.경쟁상태(racecondition)은 무엇입니까**

공유자원에 여러 프로세스가 접근해서 데이터의 일관성을해칠수있는 상태를 의미합니다.

### **8.1 경쟁상태가 발생할수 있는경우는 무엇이있습니까**  
커널에서 작업을 수행할때 인터럽트가 발생하면 경쟁상태가 발생할수 있습니다. 이때 커널에서 작업중일때 인터럽트가 발생하지 않도록 disable해놓으면 해결됩니다. 
프로세스가 커널에서 작업중일때 문맥교환이 발생하면 경쟁상태가 발생합니다. 이떄도 커널모드에서 작업중이면 문맥교환이 발생하지 않도록 하면 해결됩니다. 
공유메모리 내의 커널데이터에 여러개의 프로세스가 접근하면 발생합니다. 한 프로세스가 공유데이터에 접근할때 lock을 걸어서 다른 프로세스가 접근하지 못하도록 하면 해결됩니다. 

### 8.2 동시에 공유자원에 접근하면 발생하는 문제를 해결하기 위한 방법은 무엇이 있나요  
첫번째 방법으로 스핀락이 있습니다. 스핀락은 임계영역에 접근할수 없을때 무한 루프를 돌면서 대기하면서 기다리는 방법입니다.  
무한 루프를 돌기 때문에 문맥교환이 발생하지 않고 busy waiting이 발생하게 됩니다.  

두번째는 뮤텍스입니다. 동시에 임계영역에 접근할수 있는 프로세스가 1개이고 접근할때 lock을 걸고 사용 후에 unlock을 해서 접근을 제어합니다.  
뮤텍스는 wait과 signal을 사용하는데 락킹 매커니즘은 스핀락과 같은데 busy waiting을 하는 것이 아니라 sleep상태에서 wakeup상태로 변환될때 권한을 획득합니다.  
  
뮤텍스 알고리즘은 데커,피터슨,제과점 알고리즘으로 나뉩니다.  
데커 알고리즘은 flag로 임계영역점근 여부를 정하고 turn으로 누가 접근할 차례인지 판단합니다.  
피터슨 알고리즘은 데커와 유사하지만 임계영역 접근 순서를 양보하는 것이 차이입니다.  
마지막으로 제과점 알고리즘은 가장 적은 수의 표를 가지고 있는 프로세스가 임계영역에 접근하는 방법입니다.  

마지막 방법으로 세모포어가 있습니다. 프로세스가 공유자원(임계영역)에 접근하면 세마포어를 감소하고 사용하지 않으면 세마포어를 증가시킵니다. 따라서 세마포어가 0이 되면 가용할수 있는 자원이 없기 때문에 더이상 접근할수 없습니다.  
이때 가용할수 있는 자원의 수가 2개 이상이면 카운팅 세마포어 1개라면 이진 세마포어(뮤텍스)라고 부릅니다.  
    


---

# 9.메모리 관리 기법  
### 9.1 메모리 관리 기법 중 연속 메모리 관리 기법에 대해 설명하시오  
연속 메모리 관리 기법은 프로그램 전체가 하나의 커다란 메모리에 연속적으로 할당되는 것입니다.  
연속 메모리 관리 기법은 고정분할,동적분할 기법으로 나뉩니다.  
고정분할 기법은 말그대로 고정된 크기로 분할하는 것인데 내부 단편화가 발생합니다.  
동적분할 기법은 파티션이 분할되는 크기가 동적입니다. 외부 단편화가 발생합니다.  

### 9.2 내부 단편화와 외부 단편화에 대해 설명하시오  
내부 단편화는 고정 크기 파티션을 할당했을때 해당 크기를 다 사용하지 못해서 발생하는 단편화입니다.  
외부 단편화는 동적 크기 파티션을 할당했을때 메모리 전체에서 남는 메모리가 생기는 것을 의미합니다.  

### 9.3 불연속 메모리 관리 기법에 대해 설명하시오  
불연속 메모리 관리 기법은 프로그램의 일부가 서로다른 주소에 할당되는 것입니다.  
불연속 메모리 관리 기법은 페이징(고정),세그멘테이션(동적)으로 나뉩니다.  
단순 페이징은 고정된 크기로 할당하여 내부 단편화는 있지만 외부 단편화는 발생하지 않습니다.  
단순 세그멘테이션은 메모리를 동적분할해서 프로세스를 할당하므로 메모리 사용효율이 증가하고 오버헤드가 감소합니다. 하지만 여전히 외부 단편화는 존재합니다.  
가상 메모리 페이징은 프로세스를 전부 메모리에 올려서 사용하느 것이 아니라 필요한 페이지가 생기면 로드하는 방식입니다. 필요할때마다 로드해야 하므로 오버헤드가 발생합니다.  
가상 메모리 세그멘테이션 또한 필요할때 마다 메모리로 로드하므로 오버헤드가 발생합니다.  

---

# 10. 엔디안이란 무엇입니까  
컴퓨터 메모리에 연속된 바이트를 할당하는 방법입니다.  

### 10.1 리틀엔디안과 빅엔디안의 차이를 설명하시오  
우선 빅엔디안은 사람들이 평소에 읽는 방식과 유사합니다.(디버깅 유리)  
최상위 비트가 앞에오므로 낮은 주소에 앞의 값이 오게됩니다.  
  
리틀엔디안은 빅엔디안과 읽는 순서가 반대입니다.  
최상위 비트가 가장 뒤에오고 최하위 비트가 가장 앞에오게됩니다.  
이러한 점 덕분에 수가 커지더라도 오버헤드가 발생하지 않습니다.  


# 11. 가상메모리란?  
실제로 존재하는 메모리가 아니라 메모리 역할을 하는 가상의 메모리입니다.  
실제 프로그램을 수행할때 프로그램 전체가 메모리에 있을 필요가 없습니다. 실행되어야 하는 부분만 메모리상에 있으면 되기 때문입니다.  
이를 위해 필요한 것이 가상메모리입니다.  
논리적 연속성을 제공해주고 실제 메모리크기보다 더 큰 공간을 사용할수 있다는 장점이 있습니다.
