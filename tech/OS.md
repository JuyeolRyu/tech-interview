# 1. 운영체제
**운영체제**란 시스템의 자원을 효율적으로 관리하고 유저가 사용하기 편하도록 환경을 제공해주는 시스템 소프트웨어를 의미합니다.  
운영체제의 기능으로는 **시분할 시스템**이 있는데 다수의 작업을 계속해서 번갈아가면서 실행해서 **동시에 처리되는것처럼** 보이게 해주고 **응답시간을 짧게** 합니다.  
그리고 운영체제는 중요한 자원에 대한 접근 권한을 나누기 위해 **유저모드**와 **커널모드**로 나누어서 사용합니다.  
운영체제의 종류는 **Window**,**Linux**,**Unix**등이 있고 Window는 주로 개인용으로 사용되고 Linux와 Unix는 서버용으로 사용됩니다.  

#### **📝시스템콜**
> **시스템콜**이란 **커널 영역**의 기능을 **유저모드**에서 사용가능 하도록 해주는 기능입니다.  
> 다시말해 프로세스가 하드웨어에 직접 접근하여 필요한 기능을 사용할수 있게 해주는 것을 의미합니다.  

#### **📝시스템콜 명령어**
> Fork(): 자식프로세스를 생성하는 시스템콜  
> Wait(): Child가끝날때까지기다리는 시스템콜  
> Exec(): Fork해온 기존 프로세스와 다른 기능을 하도록 하게 해주는 시스템콜

<br/>  
<br/>  
<br/>  

# 2. 프로세스와 스레드  
**프로세스**는 메모리에 적재되어 실행중인 프로그램을 의미하고 운영체제로부터 자원을 할당받는 **작업의 단위**입니다.  
각각의 프로세스는 독립적으로 동작하며 다른 프로세스의 자원에 접근할수없습니다. 프로세스간 데이터를 교환하기 위해서는 **IPC(Inter Process Comunication)** 을 사용해야 합니다.  
프로세스는 공유하는 메모리가 없기 때문에 기존의 캐시와 상관없는 데이터를 탐색해야 하기 때문에 **Context Switch**에 많은 비용이 발생합니다.  
  
**스레드**란 프로세스의 **실행 단위**입니다.  
하나의 프로세스에서 여러개의 스레드가 동작하고 각각의 스레드는 **힙**,**데이터**,**코드 영역**을 공유하고 별도의 **스택**을 가집니다.  
스레드간 공유메모리를 가지기 때문에 **데이터 전송**과 **Context Switch**에 많은 비용이 발생하지 않습니다.  
또한 스택을 제외한 메모리를 공유하므로 하나의 스레드에서 공유 메모리 영역에 손상시키면 전체의 스레드가 동작하지 않는 단점이 있습니다.  

#### **📝프로세스의 메모리 영역**  
> **Code**: 코드자체가 저장됩니다.  
> **Data**: 전역변수,정적변수,배열과같은 데이터가 저장됩니다.  
> **Heap**: 동적 데이터가 저장됩니다.  
> **Stack**:지역변수,매개변수, 함수가 저장됩니다.

#### **📝Context switching**  
> cpu는 한번에 하나의 프로세스만 실행 가능합니다. 이때 최대한 동시에 프로세스들이 실행되는 것처럼 보이도록 다른 프로세스와 교체할때 **context switching**을 사용합니다.  
> **Context swithcing**의 실행과정은 우선 실행중인 프로세스의 상태를 **PCB**에 저장합니다.  
> 그리고 실행하려는 프로세스의 상태를 복원해 레지스터에 저장해 실행하면 됩니다.  

#### **📝PCB(Process Control Block)**
> **PCB**는 프로세스의 메타데이터를 저장하고 다음 실행 명령어의 주소를 저장하고 있습니다.  
> 프로세스의 **Context switching**을 할때 현재 프로세스의 상태를 기억하는 용도로 사용합니다.  
<br/>  
<br/>  
<br/>  

# 3. 인터럽트
프로그램 실행 도중에 **우선적으로 처리해야할 작업**이 생길 경우 먼저 처리하고 기존의 작업으로 복귀하는 것을 **인터럽트**라고 합니다.  
인터럽트의 종류는 **외부인터럽트**,**내부인터럽트**,**소프트웨어인터럽트**가 있습니다.  
**외부인터럽트**는 입출력 장치등에서 오는 외부적요인으로 발생합니다.  
**내부인터럽트**는 잘못된 명령이나 데이터를 사용했을때 (0으로나누기 ,버퍼오버플로우...) 발생합니다.  
마지막으로 **소프트웨어 인터럽트**는 사용자가 다른 프로세스를 실행시키거나 감시 프로그램을 호출할때 발생한다.  

#### **📝인터럽트 동작 과정**
> 인터럽트 요청이 발생하면 우선 현재 실행중인 명령을 완료합니다.  
> 그리고 PCB에 현재 프로세스의 상태를 저장하고 인터럽트가 발생한 요청을 찾아 해당 요청을 처리합니다.  
> 마지막으로 PCB에서 기존 프로그램 상태를 복원하고 프로세스 실행을 재개합니다.  
<br/>  
<br/>  
<br/>  

# 4. IPC란?
프로세스는 독립된 메모리 공간을 가지기 때문에 통신을 위한 기법이 필요합니다. 이때 프로세스간 통신을 가능하도록 해주는 것이 **IPC(interprocesscommunication)** 입니다.  

#### **📝IPC종류**  
* **익명파이프**  
> 통신할 프로세스를 명확히 알고 있는 경우 사용합니다.(=> 같은 부모 프로세스를 가진 경우)  
한쪽방향으로만 통신이 가능한 **반이중통신**입니다.  
간단하게 사용할수 있다는 장점이 있지만 전이중통신을 위해 2개의 파이프를 만들어야 한다는 단점이 있습니다.
  
* **네임드파이프**  
> 전혀 모르는 프로세스간 통신에 사용돠고 다른 기능들은 익명파이프와 동일합니다.  
  
* **메시지큐**
> 파이프처럼 데이터의 흐름이 아니라 메모리에 번호를 붙인 데이터를 적재해서 통신하는 방법입니다. 또한 파이프와 같이 단방향 통신을 지원합니다.  
  
* **공유메모리**
> 프로세스간 메모리를 공유해서 사용하는 방법입니다.  
> 공유메모리는 처음 사용할때만 시스템콜을 사용하고 중개자 없이 바로 메모리에 접근이 가능하므로 **IPC**중 가장 빠릅니다. 하지만 데이터의 일관성을 유지해야 하기 때문에 **동기화**가 중요합니다.  
  
* **메모리맵**
> **메모리맵** 또한 공유메모리처럼 메모리를 공유합니다.  
> 다른점은 파일을 열고 메모리에 맵핑 시켜서 공유하는 방식입니다. 대용량의 데이터를 공유할 때 사용하는 방식입니다.  
  
* **소켓**  
> 소켓은 일반적으로 네트워크에서 데이터 통신에 사용되는 방식입니다.  
> 하지만 같은 운영체제 상에서 실행되는 두 프로세스도 **소켓**을 통해 통신이 가능합니다.  
> 소켓은 파이프처럼 연결을 진행하고 1대1로 데이터를 통신하는 방법입니다.  
<br/>  
<br/>  
<br/>  

# 5. 스케줄링
Cpu나 자원을 **효율적으로 사용**하기 위해 프로세스를 cpu에 할당하는 순서를 정해주는 것을 의미합니다.  
스케줄러의 목표는 **많은처리량**,**빠른응답시간**,**deadline 맞추는것**입니다.  
크게는 **장기,중기,단기 스케줄러**로 구분하고 cpu 점유 탈취 가능 여부로 **선점형 스케줄러**와 **비선점형 스케줄러**로 구분됩니다.
  
#### **📝장기,중기,단기 스케줄러**
>**장기 스케줄러**는 스케줄러 큐에 적재할 task를 선정하는 것이 목표입니다.  
**단기 스케줄러**는 장기스케줄러로 선택한 task들의 우선순위를 결정해줍니다. 선점형,비선점형 스케줄러가 이에 속합니다.  
마지막으로 **중기 스케줄러**는 우선순위가 낮은 task를 스케줄링 큐에서 내리는 역할을 합니다.  
  
#### **📝비선점형 스케줄러**
> **비선점형 스케줄러**는 프로세스가 종료되지 않는 이상 자원을 반납하지 않습니다. 정해진 순서대로 프로세스가 처리되기 때문에 **오버헤드**가 적고 **기아상태**에 빠질 일도 없습니다.  
> 비선점형 스케줄링은 일괄처리 되는 **배치시스템**에 사용됩니다.  

#### **📝비선점형 스케줄러 종류**  
> **FCFS**: 먼저 큐에 들어간 순서대로 처리합니다.  
**SJF**: 가장 짧은 수행시간을 가지는 작업을 먼저 처리합니다.  
**HRN**: SJF에 에이징기법을 추가한 방식입니다.  
**Priority스케줄링**: 대기중인 프로세스에 우선순위를 부여하여 할당합니다.    

#### **📝선점형 스케줄러**
> **선점형 스케줄러**는 실행중인 프로세스를 중지하고 다른 프로세스가 CPU를 점유할수 있게 해주는 스케줄러입니다.  
>  우선순위가 존재함으로 특정task가 자원을 할당받지 못하는 **기아현상(starvation)** 이 발생할 수 있습니다. 또한 **Context Switching**이 자주 발생할 수 있어서 **오버헤드**가 발생할수 있습니다.  
>  선점형 스케줄링은 대화형 시스템에 많이 사용됩니다.   

#### **📝선점형 스케줄러의 종류**   
>  **SRT(Shortest Remaining Time)** : **SJF** 알고리즘에 선점형 스케줄링 기법을 추가한것입니다. 남은 시간이 가장 작은 task가 우선순위가 높습니다.  
>  **라운드로빈** : 각각의 프로세스마다 **timequantum**을 할당해서 timequantum만큼 실행하고 다음 프로세스를 실행하는 방식입니다. 문맥교환이 자주 발생해서 **오버헤드**가 발생합니다.  
>  **Multilevel-queue** : 라운드로빈에 큐를 여러개 사용하는 방식입니다. 라운드로빈처럼 timequantum이 주어지고 timequantum만큼 실행하지만 다 실행되지 않았으면 우선순위가 낮은 다음 큐로 내려가게 됩니다. **짧은 작업을 처리**할때 유리하고, **turnarround** 평균시간을 줄여줍니다.  
>  **멀티레벨피드백큐** : 멀티레벨큐에서 기아상태에 빠지는 것을 방지하기 위해 **에이징기법**을 추가한 스케줄링 기법입니다.  

#### **📝에이징 기법**   
> 특정 프로세스의 우선순위가 낮아서 무한정 기다리는 경우(**기아상태**)를 방지하기 위해서 기다린 시간에 비례해서 우선순위를 높여주는 방법입니다.
<br/>  
<br/>  
<br/>  

# **6. 데드락(교착상태)**  
프로세스들이 서로의 자원을 반환하기 기다리고 있는 상태를 의미합니다.  
**상호배제**,**점유대기**,**비선점**,**순환대기** 모두 충족할때 발생합니다.
  
**상호배제**: 하나의 자원에 동시에 하나의 프로세스만 접근할수 있는 속성입니다.  
**점유대기**: 자원을 가지고 있는 상태에서 다른 프로세스가 사용하는 자원의 반납을 기다리는 것을 의미합니다.  
**비선점**: 다른 프로세스가 점유중인 자원을 가져올수 없는 것을 의미합니다.  
**환형대기**: 각각의 프로세스가 다음 프로세스가 원하는 자원을 가지고 있는 상태를 의미합니다.

#### **📝교착상태 해결방법**   
> **예방&회피**,**탐지&회복**,**무시**가 있습니다.  
> 예방은 교착상태 발생 조건중 하나를 제거해서 해결하지만 자원의 낭비가 큽니다.  
> 회피는 교착상태가 발생하지 않도록 회피하는 방법입니다. **은행원**알고리즘이 있습니다.  
> 탐지&회복은 교착상태가 되도록 허용하고 탐지를 하고 회복하는 방법입니다. **자원 할당 그래프**를 통해 교착상태를 탐지하고 프로세스를 모두 제거하거나 하나씩 제거하는 방법을 사용해 회복합니다.  
> 마지막으로 무시는 대부분의 시스템은 교착상태가 잘 발생하지 않으므로 무시하는 방법입니다.  

#### **📝은행원 알고리즘**  
> 안전상태를 유지할수 있는 요구만 수락하고 불안전 상태를 유발할수 있는 요구는 거절하는 방법입니다.  
**안전상태**란 시스템이 교착상태를 일으키지 않고 각 프로세스가 요구하는 자원을 할당할수 있는 상태를 의미합니다.  
반대로 **불안전상태**란 시스템이 교착상태를 일으킬 가능성이 있는 상태입니다. 또한 각 프로세스가 요구한 양만큼 자원을 할당할수 없는 경우입니다.  
  
> **은행원 알고리즘**이 수행되기 위해서는 각각의 프로세스가 **필요로하는 최대 자원의 양**, 그리고 각 프로세스가 **사용하고 있는 자원의 양**, 마지막으로 **사용가능한 자원의 양**을 알아야 합니다.  
예를 들면 12개의 자원을 보유하고 있고 프로세스 3개가 각각 10,9,9개의 자원을 요구하는 상황입니다.  
그리고 a,b,c 프로세스에 자원을 1,2,6개씩 할당합니다.
여기서 a나b 프로세스에 추가적으로 자원을 할당하는 경우는 불안전 상태를 유발할수 있으므로 거절하고 c에서 요청하는 자원을 할당하는 것은 안전상태이므로 허가해주게됩니다.  
<br/>  
<br/>  
<br/>  

# 7. 경쟁상태(Race Condition)
**공유자원**에 여러 프로세스가 접근해서 데이터의 **일관성**을 해칠수 있는 상태를 의미합니다.  
경쟁상태는 커널에서 작업을 수행할때 **인터럽트가 발생**하면 경쟁상태가 발생할 수 있습니다. 이때 커널에서 작업중일때 인터럽트가 발생하지 않도록 disable해놓으면 해결됩니다.  
프로세스가 커널에서 작업중일때 **문맥교환이 발생**하면 경쟁상태가 발생합니다. 이떄도 커널모드에서 작업중이면 문맥교환이 발생하지 않도록 하면 해결됩니다.  
공유메모리 내의 커널데이터에 **여러개의 프로세스가 접근**하면 발생합니다. 한 프로세스가 공유데이터에 접근할때 lock을 걸어서 다른 프로세스가 접근하지 못하도록 하면 해결됩니다.  
  
#### **📝경쟁상태 해결방법**  
> 첫번째 방법으로 **스핀락**이 있습니다. 스핀락은 임계영역에 접근할수 없을때 무한 루프를 돌면서 대기하면서 기다리는 방법입니다.  
무한 루프를 돌기 때문에 **문맥교환이 발생하지 않고** **busy waiting**이 발생하게 됩니다.  
  
> 두번째는 **뮤텍스**입니다. 동시에 임계영역에 접근할수 있는 프로세스가 1개이고 접근할때 lock을 걸고 사용 후에 unlock을 해서 접근을 제어합니다.  
뮤텍스는 wait과 signal을 사용하는데 락킹 매커니즘은 스핀락과 같은데 busy waiting을 하는 것이 아니라 **sleep상태에서 wakeup**상태로 변환될 때 권한을 획득합니다.  
뮤텍스 알고리즘은 **데커**,**피터슨**,**제과점** 알고리즘으로 나뉩니다.  
데커 알고리즘은 flag로 임계영역점근 여부를 정하고 turn으로 누가 접근할 차례인지 판단합니다.  
피터슨 알고리즘은 데커와 유사하지만 임계영역 접근 순서를 양보하는 것이 차이입니다.  
마지막으로 제과점 알고리즘은 가장 적은 수의 표를 가지고 있는 프로세스가 임계영역에 접근하는 방법입니다.  
  
> 마지막 방법으로 **세모포어**가 있습니다. 프로세스가 공유자원(임계영역)에 접근하면 세마포어를 감소하고 사용하지 않으면 세마포어를 증가시킵니다. 따라서 세마포어가 0이 되면 가용할수 있는 자원이 없기 때문에 더이상 접근할수 없습니다.  
이때 가용할수 있는 자원의 수가 2개 이상이면 **카운팅 세마포어** 1개라면 **이진 세마포어(뮤텍스)** 라고 부릅니다.  
<br/>  
<br/>  
<br/>      

# 8. 메모리 관리 기법  
부족한 메모리를 효율적으로 사용하기 위한 기법입니다. 메모리에 연속적으로 할당하는지 여부에 따라 **연속 메모리 할당**,**불연속 메모리 할당**으로 나누어집니다.  

#### **📝연속 메모리 관리 기법**   
> **연속 메모리 관리 기법**은 프로그램 전체가 하나의 커다란 메모리에 **연속적으로 할당**되는 것입니다.  
연속 메모리 관리 기법은 **고정분할**,**동적분할** 기법으로 나뉩니다.  
고정분할 기법은 말그대로 고정된 크기로 분할하는 것인데 **내부 단편화**가 발생합니다.  
동적분할 기법은 파티션이 분할되는 크기가 동적입니다. **외부 단편화**가 발생합니다.  

#### **📝불연속 메모리 관리 기법**   
> **불연속 메모리 관리 기법**은 프로그램의 일부가 서로 **다른 주소에 할당**되는 것입니다.  
불연속 메모리 관리 기법은 **페이징(고정)**,**세그멘테이션(동적)** 으로 나뉩니다.  
**단순 페이징**은 고정된 크기로 할당하여 **내부 단편화**는 있지만 외부 단편화는 발생하지 않습니다.  
**단순 세그멘테이션**은 메모리를 동적분할해서 프로세스를 할당하므로 **메모리 사용효율이 증가**하고 **오버헤드가 감소**합니다. 하지만 여전히 **외부 단편화**는 존재합니다.  
**가상 메모리 페이징**은 프로세스를 전부 메모리에 올려서 사용하느 것이 아니라 **필요한 페이지가 생기면 로드**하는 방식입니다. 필요할때마다 로드해야 하므로 **오버헤드**가 발생합니다.  
**가상 메모리 세그멘테이션** 또한 **필요할때 마다 메모리로 로드**하므로 오버헤드가 발생합니다.  

#### **📝단편화**   
> **내부 단편화**는 고정 크기 파티션을 할당했을때 해당 크기를 다 사용하지 못해서 발생하는 단편화입니다.  
**외부 단편화**는 동적 크기 파티션을 할당했을때 메모리 전체에서 남는 메모리가 생기는 것을 의미합니다.  
<br/>  
<br/>  
<br/>    

# 9. 가상메모리란?  
실제로 존재하는 메모리가 아니라 메모리 역할을 하는 **가상의 메모리**입니다.  
실행되어야 하는 부분만 메모리상에 있으면 되기 때문에 실제 프로그램을 수행할때 프로그램 전체가 메모리에 있을 필요가 없습니다.  
이를 위해 필요한 것이 가상메모리입니다.  
가상메모리는 **논리적 연속성**을 제공해주고 실제 메모리 크기보다 더 큰 공간을 사용할수 있다는 장점이 있습니다.  
<br/>  
<br/>  
<br/>    

# 10. 엔디안이란?
컴퓨터 메모리에 연속된 바이트를 할당하는 방법입니다.  
엔디안은 **빅엔디안**과 **리틀엔디안**으로 나뉩니다.  
  
#### **📝리틀엔디안**   
> **리틀엔디안**은 빅엔디안과 읽는 순서가 반대입니다.  
최상위 비트가 가장 뒤에오고 최하위 비트가 가장 앞에오게됩니다. 이러한 점 덕분에 수가 커지더라도 **오버헤드가 발생하지 않습니다**.  
  
#### **📝빅엔디안**   
> **빅엔디안**은 사람들이 평소에 읽는 방식과 유사합니다.  
최상위 비트가 앞에오므로 낮은 주소에 앞의 값이 오게됩니다. 이러한 특성 때문에 **디버깅에 유리**하다는 장점이 있습니다.  
